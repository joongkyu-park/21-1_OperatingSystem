# os 1주차-2

이번학기에 중요하게 알아놔야할내용
1. DMA
2. Interrupt
3. Caching

os의 정의?
os는 하드웨어 관리 -> resource(자원) = 하드웨어 관리

-3-
os는 무엇이냐??
일반적인 정의는… 딱히 없음
이유? os가 너무 다양해서. 요즘에는 안드로이드,ios도 있고 .. 등등

하지만 os의 역할을 살펴보고, 그 공통적인 역할을 바탕으로 os를 정의해보자

그래서, os는 무엇이냐?
os도 프로그램이다. 마찬가지로 main 함수를 가지고 있는 프로그램 일반 프로그램과 다른점? 수천, 수만 개의 파일이 하나의 프로그램, 그 파일을 디렉토리로 관리하는 복잡한 프로그램. 하드웨어를 관리해야하기때문에 c언어(로우레벨언어)로 주로 만듬.
os가 하는일?
1. 컴퓨터하드웨어를 관리. 어떤하드웨어? cpu, 메모리, 스토리지(hdd, ssd), IO 디바이스 하드웨어 = resource 라고 표현.
2. 프로그램의 수행을 제어. 다른 응용프로그램들의 수행을 제어. 스케줄링이나 cpu할당을 잘해줘야함.

-4-
1. 하드웨어 관리 측면
2. io 디바이스 접근  —-ㄱ
3. 파일 접근            ——-> 하드웨어 제어
4. accounting 이게뭐지? -> 작업관리자. 현재 cpu를 얼만큼쓰고 메모리를 얼만큼 쓰고.. 등 -> 통계적인 내용을 제공하는 것.
5. error detecton

1. 프로그램 수행 제어 측면
2. 스케줄링 마치 우리가 오늘 밥먹고 수업1듣고 수업2 듣고 뭐하고 할일을 할당하듯이 cpu에 프로세스를 할당해주는것

- error reporting 대표적으로 segementation fault

-5-
그럼 os는 어디에 위치해있느냐?

컴퓨터 하드웨어를 제어하기때문에,
응용프로그램과 컴퓨터하드웨어 사이에 있다.

응용프로그램은 os를 통해서 컴퓨터하드웨어에 접근할 수 있다. 다른방법은 X
응용프로그램을 다이렉트로 컴퓨터하드웨어에게 접근x -> 시스템이 완전히 파괴되니까.
따라서 os라는 안정적인 소프트웨어를 통해서만이 접근할 수 있도록.
실질적으로는 무슨뜻?
system call.
응용프로그램은 system call을 호출해서 -> 컴퓨터 하드웨어에 접근.
시스템콜 호출?
시스템콜은 api로 되어있다. (즉 함수이다)
응용프로그램에서 이 함수를 호출하게 되면 
그제서야 하드웨어에 접근할 수 있게된다.

또한가지.
system and application programs라고 ppt에 나와있다.
application programs는
는 게임이나, 워드나, 그런 응용프로그램들
system programs는
응용프로그램의 일종이라고 봐도되고,
“시스템을 관리하기 위한 응용레벨 프로그램”
대표적으로 작업관리자. -> 목적 : 시스템이 어떻게 동작하는지 보는 프로그램, 응용레벨의 프로그램.
시스템 프로그램도 역시나 하드웨어에 직접접근x
os를 통해서만 접근가능하다.

-5-
os의 목적

결국에 컴퓨터하드웨어를 효과적으로 관리하는것.
어떻게?
그건 이번학기에 배우는 내용

그렇다면 효과적으로 관리하는 이유는 뭘까?
결국엔 os위에서 동작하는 응용프로그램들을, 응용프로그램들 목적에 맞도록 쉽게 사용하기위해서.
ex)게임. 막 키보드눌러도 렉걸리고, 네트워크 끊기고..
유트브보는데 네트웤 연결잘안되고 영상 끊기고.. 영상이 낮은퀄리티의 영상으로 대체되고…
-> 이러한 user problems 들을 해결해주고,
쉽게 응용프로그램을 사용할 수 있도록 해준다.

os하면 제일먼저생각나는것?
dos, windows, iPad 의 인터페이스 사진들.
DOS는 CLI(Command Line Interface)
프로그램을 실행하려면 명령을 쳐야함.
그 이후에 Windows에 와서 GUI
최근에 와서는(아이패드, 아이폰) APP 개념으로 업그레이드
-> 즉 사용자가 사용하기 쉽게 진화한다.

-6-
다시.
os는 하드웨어를 관리한다.
-> os는 resource allocator이다.
하드웨어 관리가 어려운이유.
프로세스 = 실제 실행중인 프로그램
무수히 많은 프로세스가 동시에(concurrently하게) 자원요청을 하기때문에.
* concurrently하게 쓰인다?
여러 프로세스들이 동시에 실행되는것처럼 보이지만,
세분하게 짤라보면 짧은시간에 여러프로그램들이 한번씩 수행됨. 너무 잘게 짤라서 동시에 실행되는거처럼 보임. 이게 concurrently

프로세스들의 conflicting request를 조율한다.
책에서는 os를 government에 비유했다.

os는 프로그램을 제어한다.
os는 control program이다.
프로그램을 스케쥴링하고, 에러나 improper한 use를 막아준다.

-8-
또 다른정의
커널 : 핵심, 코어라는 뜻.
보통 리눅스 오퍼레팅 시스템 이라고 부르지않고
리눅스 커널 이라고 부른다.
의미하는 바가 뭐냐.
os에서도 코어가 되는 부분을 리눅스 커널이라고 부른다.
os는 너무 광범위하기 때문에 커널이라고 부른게 더 명확. 1. 하드웨어관리, 2. control execution
ex) 안드로이드 os는 리눅스 커널을 포함하고있다. -> os중에서도 코어부분.

-9-
컴퓨터 시스템이 어떻게 working 하는가.

컴퓨터 시스셈
- personal computers(개인pc)
- large-scale systems(서버) -> 주로 이런 곳을 ‘data center’라고한다. 그곳에서 서버들이 housing 된다.
- hand-held systems(모바일)

-10-
어느 시스템이나 같은 resources 가지고있다.
-> 이 리소스들이 어떻게 관리되나.

프로그램을 수행하려면,
프로그램이 메모리에 있어야한다.

메모리가 cpu와 interaction할 수 있는 유일한 매체.

프로그램을 메모리로 올려놓고 수행.

키보드나 마우스같은 장치들도 메모리로 올려놓고
cpu가 처리.

한마디로 결국, cpu와 장치들은 메모리를 차지하려고 경쟁하고있다.
이때 필요한 2가지 중요개념.
1.DMA
2.Interrupt

-11-

…

요즘엔 멀티코어(멀티프로세서) 사용.
여러개의 코어가 병렬적으로(parallel) 수행.
-> 프로세스 할당이 중요해짐. -> os가 중요함.

-12-
DMA가 무엇이냐?..

-14-
IO디바이스는, 디바이스만 있으면 먹통이다. 동작안됨. -> 이 디바이스를 제어할수있는 컨트롤러가 있어야한다. 디스크도. 즉 하드웨어를 제어하기위해선 컨트롤러가 필요. 컨트롤러에 로컬스토리지가 다 하나씩있다. 로컬스토리지 라는 표현보단 로컬버퍼
조금한만 메모리공간
데이터를 읽어서 잠시 저장해야함
그래서 메모리공간필요.
cpu와 메모리와 디바이스를 이어주는것은 IO bus이다. 그냥 통로같은것.

cpu가 데이터를 읽고 쓰도록 명령을 날려야함 -> io transcation

순서.
cpu가 디바이스에게 명령전달(initiation)
작업이 끝날때까지 디바이스는 메모리와 계속 작업.
작업이 끝나면 cpu에게 interrupt를 통해 알려줌.

io transaction을 cpu간섭없이 하는것
-> 이것이 DMA
그 사이에 cpu는 다른일(다른 프로세스수행)을 한다.
작업이 다 끝나면,
interrupt로 cpu에게 알려준다.

-15- 
dma 가 없다면?
cpu가 계속 간섭. -> 다른일 아무것도 못함

=> io와 디바이스와 cpu는 concurrently하게 실행될 수 없다.

-13-
io transaction는 bus들을 통해 이루어진다.

DMA는 read, write bus transaction을 cpu의 간섭없이 수행할 수 있다.
cpu는 initiation만 하고 다른 operation을 수행한다.
디바이스컨트롤러는 오퍼레이션이 끝날때 interrput를 통해 cpu에게 알려준다.

-16-
interrupt는
io가 끝났을때 cpu에게 알려주는 메커니즘

os는 메모리에 있는 다른 프로그램들을 수행중,
interrupt발생. -> io가 끝났다는뜻. (ex . A라는 디바이스로부터)
os는 무조건적으로 하던 일 멈추고,
interrupt service routine을 수행해야함. (ISR)
ISR는 interrupt가 발생했을때 수행해야하는 함수.
ISR의 주소는 Interrupt vector에서 찾는다.
Interrupt vector.에는
source에 해당하는 ISR의 주소가 담겨있다.
태이블임.
중요한건 무조건적이라는 것. 무조건적으로 분기함.
ISR 짧고 간결하게 작성해야한다.

끝나면  하던일을 멈췄던 그 위치로 다시 돌아와서 수행.

