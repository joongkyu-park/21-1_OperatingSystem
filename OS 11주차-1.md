# OS 11주차-1



OS 11주차-1

16)
리눅스에서, 프로세스의 어드레스 스페이스는 다음과 같이 나타난다.

중요한 것은 다음과 같이 출력되는 영역들이 virtual address라는 것.

17)
2개의 서로다른 프로세스의 어드레스 스페이스를 조사해보았다. (PID가 다름)
a, b 프로세스

18)
a, b는 다른 프로그램인데 어드레스 스페이스의 range가 같다…!!
-> virtual 어드레스는 프로그램 상에서 보이는 주소(CPU가 바라보는). physical 어드레스는 아니다.
버츄얼 어드레스이기 때문에 서로 다른 프로세스의 버츄얼 어드레스는 값이 같지만 전혀 상관관계가 없다. -> 매핑테이블로 피지컬 어드레스로 변환되어야한다.

이 공간은 프로세스 마다있다.

핵심은 버츄얼 어드레스는 피지컬 어드레스로 변환이 되어야한다.
-> 매핑 테이블을 이용하여.

따라서 프로세스마다 매핑 테이블이 있어야한다.
-> PCB에 있는 데이터스트럭쳐 이다.

19)
로딩
수행할 프로그램을 메모리로 올리는 것

다이나믹 로딩
동적으로 로딩하는 것.
프로그램 중 일부만 로딩하자. 호출이 안되는 것은 로딩하지말자. 로딩을 미루자
메모리 사이즈를 효과적으로 쓰기 위해, 호출이 안되는 루틴은 로딩을 안하는 것.

유용한 경우.
에러루틴 같은경우 함수가 거의 호출되지않는다.
자주 호출이 안되는, 파트가 많은 프로그램 같은 경우.

=> 프로그램 전체를 올리는게 아니라 일부만 올리기 떄문

다이나믹 로딩은, OS가 아니라 라이브러리에서 지원을 받아 수행되는 형태.

20)
다이나믹 링킹
여러개의 오브젝트 파일을 묶어 하나의 실행파일을 만드는 링킹과정을
execution time전 까지 미룬다.

직관하고는 조금 다르다…
링킹, 즉 컴파일하고나서 여러 오브젝트 파일 묶어 하나의 실행파일을 만드는게 아니라
수행시간까지 미룬다…?
왜?
-> 메모리를 효과적으로 활용하기 위함.
어떻게?
2개의 개념 비교 필요
Shared libraries -> 다이나믹 링킹 사용
static library -> 다이나믹 링킹 사용x

다이나믹 링킹은 쉐어드 라이브러리에 효과적인다.

21)
스태틱 라이브러리는 라이브러리가 프로그램상에 아예 포함이 되는것.
이 코드가 프로그램마다 duplicate되어야한다 -> 메모리 비효율적

스태틱 라이브러리를 쓰는 경우 추후에 라이브러리를 업데이트를 해야한다면
다시 링킹을 해야한다, 즉 새로운 버전으로 리컴파일해야한다.
-> 라이브러리 업데이트가 잦은경우 쉐어드 라이브러리 사용이 효과적

![OS 11주차-1](images/OS%2011주차-1.png)

쉐어드 라이브러리는 자기 영역이 아닌 영역을 접근해야한다
-> 오직 OS만이 가능한 작업

따라서 다이나믹 링킹은 OS의 도움이 필요하다.

22, 23)
스태틱 라이브러리

쉐어드 라이브러리
Stub : 어떻게 나중에 라이브러리를 locate시킬 것인지 방법에 대한 정보가 들어있음.
	execution time에 Stub이 라이브러리의 주소로 대체됨
	-> 메모리를 효과적으로 사용할 수 있다.

링킹 과정을 실행시간 까지 미룬다.
실행시간에 
어떻게 링킹할 것이에 대한 정보, 어떻게 쉐어드 라이브러리에 대한 정보를 Stub에 저장

실행시간에 다이나믹 링킹이 완료되면 Stub은 라이브러리의 주소로 대체된다.

24)
Swapping

결국에 버츄얼스페이스를 쓰는 이유는 메모리 공간을 효과적으로 사용하기 위함.

필수적으로 야기되는 이슈는, 메모리 공간이 한정되어있기 때문에 누군가는 swapping out 해야한다.

backing store : swapping out된 프로그램을 킵하고 있는 디스크의 영역
![OS 11주차-1-1](images/OS%2011주차-1-1.png)

backing store은 일반 스토리지와 다르게 os에서 별도로 관리해준다.

Roll out, roll in : swapping out in과 동일한 개념인데, 우선순위 개념을 추가한것. 별로 중요x

25)
swapping out의 오버헤드를 분석하는 것이 중요하다

latency : 필수 불가결한 오버헤드. 디스크를 접근할 때 초기오버헤드. 무조건 드는 비용.

1초동안에 4만킬로바이트를 운송할 수 있으면
만 킬로바이트를 운송하는데 1/4초 든다

근데 swapping out, swapping in 두 번해야하므로 1/2초
근데 8ms가 각각 디폴트로 사용되므로, 이 시나리오에서 총 516ms가 소요된다고 볼 수 있다.
![OS 11주차-1-2](images/OS%2011주차-1-2.png)

26)
이번 강의가 끝나면
![OS 11주차-1-3](images/OS%2011주차-1-3.png)

이 표를 그릴 수 있어야한다

Contiguous Allocation
제일 간단한 방법이다.
프로그램은 연속적으로, contiguous하게 저장되어야한다.

OS는 메모리에 이미 공간을 차지하고 있고, 그 이후에 여러 프로세스들이 메모리에 올라오는데
하나의 프로세스는 연속적으로 저장되어있다.
연속적이기 때문에 address translation는 시작 주소만 알면된다.
protection은 프로세스의 크기보다 작으면 된다.
즉,
address translation은 베이스 어드레스를 더해주면 되고,
메모리 프로텍션은 offset이 프로세스 크기보다 작으면된다
![OS 11주차-1-4](images/OS%2011주차-1-4.png)

베이스 어드레스를 담고있는, 프로세스의 크기를 담고 있는 MMU 필요.

27)

28)
또다른 이슈

어떻게 프로세스를 allocation할 것인가.

다음과같은 시나리오에서 프로세스 8이 끝나고 가운데 hole이 생겼다.
그다음 프로세스 9는 어디에 위치해야하나?
hole에 위치해야한다.
이미 할당되어있는 allocated partion에는 할당시킬 수 없다.

hole이 여러개 있는데, 어디에 할당시켜야하나가 이슈.
![OS 11주차-1-5](images/OS%2011주차-1-5.png)

30)
3가지 방법

First fit
첫번 째 나오는 홀

Best-fit
가장 작은 홀에
기본조건은 홀이 프로세스 크기보다 커야하는데(연속적으로, contiguous하게 저장해야하기 때문에)

Worst-fit
가장 큰 홀에

30, 31)
예시
맨 위가 first fit
중간이 best fit
맨 아래가 worst fit

32)
두번째 이슈
Fragmentation

External Fragmentation
토날 남아있는 홀의 크기는 프로세스의 크기보다 큰데, 분산되어있어서 프로세스를 로딩 못하는 상황

Internal Fragmentation
단위의 문제. 영영 사용하지 못하는 자투리 공간이 발생하면 해당 문제이다.

다음 슬라이드에서 예를 보다

33)
External Fragmentation
해결 -> 홀을 합쳐서 큰 홀을 만들면된다. Compaction.
![OS 11주차-1-6](images/OS%2011주차-1-6.png)

-> Contiguous allocation은 External Fragmentation이 발생할 수 있다.

Internal Fragmentation

주로 최소단위때문에 사용안되는 공간이 발생할 수 있다.
홀의 크기가 프로세스 크기보다 큰데, 영영 사용안되는 공간때문에 로딩을 못하는 경우
	-> 사용이 영영 안되는 경우가 발생할 수 있음.
페이징기법이 Internal Fragmentation이 발생하는 대표적인 기법

페이징기법의 최소단위는 페이지임. 4KB
-> 3KB프로세스에게 최소 단위인 4KB의 메모리공간을 할당해줘야하므로 1KB는 영영쓰지 못하는 공간이 된다.
-> Internal Fragmentation 발생

![OS 11주차-1-7](images/OS%2011주차-1-7.png)

34)
페이징 기법

Contiguous allocation과 기본적으로 다르다.
연속적일 필요 없다

피지컬 메모리는 frame 사이즈로 분할해준다.

로지컬 어드레스는 동일크기의 page로 분할
피지컬 어드레스는 동이릌기의 frame으로 분할
-> page와 frame이 각각의 최소 단위.

![OS 11주차-1-8](images/OS%2011주차-1-8.png)

핵심은 중간에 매핑 테이블,즉 page table만 가지고 있으면 address translation이 된다.

연속적이지 않아도 되기 때문에 External Fragmentation은 발생하지 않는다.

page와 frame 크기는 일반적으로 동일하고, 그 크기는 4K이다.

35)
어떻게 address가 translation 되는지 살펴보자

1. 해당 페이지에 해당하는 프레임넘버 찾기 (페이지 테이블보고)
2. 프레임의 시작주소에 offset을 더해주면됨

프레임의 시작주소 = 프레임넘버 * 페이지사이즈(4K)

![OS 11주차-1-9](images/OS%2011주차-1-9.png)

36)
따라서 1

로지컬 어드레스를 2진수로 변환 -> 두 덩이로 싹둑 잘라서 분할하여 표현
![OS 11주차-1-10](images/OS%2011주차-1-10.png)

37)
예.
![OS 11주차-1-11](images/OS%2011주차-1-11.png)

페이지크기가 4Byte라고 가정하면, 4= 2^2이므로
하위 2개의 비트를 자른다. => offset이 되는 것.

38, 39)
또다시 예
![OS 11주차-1-12](images/OS%2011주차-1-12.png)

![OS 11주차-1-13](images/OS%2011주차-1-13.png)

40)
External Fragmentation은 발생하지 않지만,
Internal Fragmentation은 페이징 기법이 가지고 있는 근본적인 문제.
최소 단위를 가지고 있이 때문에.
![OS 11주차-1-14](images/OS%2011주차-1-14.png)

41)
Internal Fragmentation으로 낭비되는 공간을 줄이자
-> 페이지 크기가 작을수록 좋다.

그러나 페이지 크기가작아지면,
ex) 페이지 크기가 2배 작아지면, 페이지 테이블의 크기가 2배 증가한다.
-> 페이지 테이블은 프로세스마다 있어야하기 때문에  	테이블의 크기가 커지면 메모리 공간을 너무 많이 차지하게 된다,,

따라서 페이지 크기는 4KB가 읾반적인 크기이다.
![OS 11주차-1-15](images/OS%2011주차-1-15.png)

