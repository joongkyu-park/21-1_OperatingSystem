# os 7주차-1

지난시간.
리눅스 스케줄링에 대해서 파악했다.

61)
알고리즘을 evaluation 해보자

디터미니스틱한 모델링
-> 간트차트를 그려봐라.
waiting time, response time 분석할 수 있다.

62)
큐잉 모델

큐잉이론이라는 분석방법이 있는데, 그 분석방법에 의해 모델링

큐잉모델에서 잘이해하면 분석을 효과적으로 할 수 있다.

큐잉모델?
1.큐(레디큐)에 도착하는, 태스크가 언제 한번씩 도착하는지. 1초에 몇개의 태스크가 도착하는지 모델링 	arrival rates
2.서비스 레이트를 모델링
	service rates
=> 위  2개를알면 큐잉이론에의해
유틸라이제이션, 에버리지 큐 렝스, 에버리지 웨이팅 타임 등이 계산된다

(큐잉모델을 자세히할려면 이거만 1학기해야한다..)

큐잉 모델은 리틀의 포뮬러에 기반을 두고 있다.
![os 7주차-1](images/os%207주차-1.png)

=> 이 큐잉모델은 앞의 간트차트(디터미니스틱한 모델)보다 더 업그레이드 됐다고 볼 수 있다.

63)
더 정확하게 해보자.
시뮬레이션.

여기서부터는 프로그램을 작성해야함

64)
더 정확하게 하자..
구현.

구현을 뭐 하면 좋겠지만 구현하는데 오버헤드가 크겠다.

5장 끝.

6장,7장
process synchronization

2)
아웃라인
![os 7주차-1-1](images/os%207주차-1-1.png)

3)
백그라운드

투머치밀크프로블럼이라는 example로 재미있는 예시.. (인터넷에 치면 바로 나오는 유명한 예)
가족이 2명이 있다.
우유를 매일 먹기 때문에 항상 냉장고에 가져다놔야한다.
하지만 우유에는
![os 7주차-1-2](images/os%207주차-1-2.png)

 유통기한이 있다. 그래서 쌓아놓으면 상한다.

-> 가족구성원 2명이 싱크가 맞지 않아서 우유를 2개 사버렸다…

이걸 해결하기위한 방법은 뭐가 있을까.
냉장고에 우유를 사러갔다고 메모장을 붙인다.

shared resorce
-> 공유되는 변수 같은 것들.
예) 스레드간의 전역변수
![os 7주차-1-3](images/os%207주차-1-3.png)

여기서 a가 공유변수이다.
+)혼자만 쓰는변수? thread specific data

-> 이런 프로그래밍을 할 때 문제가 발생할 수 있다.

4)
라킹 메카니즘.
냉장고를 그냥 잠가놓는다.
-> person2가 우유를 있는지 체크할 수 없다. 체크할 때 까지 계속 기다림

5)
실제로 스레드 환경에서 어떻게 구현되는지 보자.

실제 os에서 이게 중요하게 다뤄지는 이유는
-> race condition이 발생될 수 있기때문에 해결하는것이 매우 중요
-> data consistency가 위배될 수 있다.
ex) 4+1=5여야하는 4+1 != 5가 안될 수 있다. 데이터가 틀려버리는 것
-> data consistency가 위배되는건 말이안되는일!!

레이스컨디션이 뭐냐.

6)
2개의 스레드가 동시에 공유변수를 접근하는 케이스를 보자.

프로듀서 : 데이터를 계속 생산해내는 프로세스
컨수머 : 데이터를 계쏙 소비하는 프로세스

공유변수 count, buffer

count에 초점을 맞춰보자.

이 2개의 별도의 스레드는 concurrently하게 수행이 되는데,
레이스 컨디션이 발생할 수 있다.
다음 슬라이드에서

7)
count++, —가 실제 어셈블리어로 어떻게 구현되는지.

실제 cpu는
![os 7주차-1-4](images/os%207주차-1-4.png)

이것을 라인바이라인으로 실행한다.

8)
2개의 스레드가 concurrently하게 수행되니까.
![os 7주차-1-5](images/os%207주차-1-5.png)

중간에 공교롭게 context switch 되버려서,,

결국에 의도와 다른결과가 들어갈 수 있다.
-> data consistency를 위배.. 컴퓨터를 쓰는 목적을 상실

이런상황이 race condition!
자세히) 프로그램 수행 순서에 따라(context switch 포함해서) output이 달라질 수 있는 현상이 발생할 수 있다.

atomic operation
더이상 분할할 수 없는 코드를 의미
register1 = register1 + 1 -> 이런코드는 최종적으로 어셈블리 레벨에서 컴파일되는 코드이므로 아토믹함.
하지만 c언어 표현되는 하이레벨 코드 (count++ …)는 아토믹하지 않다.

9)
레이스 컨디션을 어떻게 피하나.

공유변수를 접근하는 코드를 실행할떄,
다른 프로세스가 끼어들지 못하도록 Lock을 거는것이 기본아이디어.
locking mechanism을 사용.

“count++”는 non-atomic한 코드인데,
이걸 atomic하게 만들어버림. 레이스컨디션이 발생안되게 하기 위해.
![os 7주차-1-6](images/os%207주차-1-6.png)

5페이지에서의 race condition 설명)
same data = shared variable 를 접급할 때
어떻게 접근하느냐, 프로세스가 어떻게 수행되느냐에 따라 결과가 달라지는 것.
공유변수를 사용할 때 이 레이스컨디션이 발생될 수 있다!
이 레이스 컨디션을 방지해야함!

어토믹하게 만드는 가장 보편적인 방법 -> semaphore

10)
최근에 preemptive한 커널이 많이쓰인다. (real-time) 때문에
이 커널이 복잡한 이유가 레이스컨디션이 발생할 상황이 많아서.
특정 변수에 2개이상의 프로세스가 접근할 수 있어서.
![os 7주차-1-7](images/os%207주차-1-7.png)

시스템콜 호출할때 컨텍스트스위치되어서 다른 프로세스가 또 접근할 수 있음.

따라서 커널프로그래밍을 할때 내가 작성하는 코드가 레이스컨디션이 되느냐 안되느냐를 잘 따져야한다.

커널에서는 레이스컨디션을 방지하기위한 여러 메소드가 제공된다.

nonpreemptive 커널에서는 아토믹하게 수행될 수 밖에 없기때문에 레이스컨디션이 발생하지 않는다.

레이스컨디션이 발생할 가능성있는 2가지 큰 틀
멀티프로세스, 유저레벨에서
커널, preemptive

11)
크리티컬-섹션 프로블럼.
포멀하게 문제로 만든것.

크리티컬섹션 : 공유변수를 접근하는 영역. -> 레이스컨디션이 발생될 수 있는 영역
이게 루프형태로 구현된것이 크리티컬-섹션 프로블럼

공유변수를 접근하는 크리티컬섹션에는 무조건 1개의 프로세스만 오도록 하자.

문제
프로토콜을 만드는데 프로세스들이 cooperate하도록.

12)
다음 3개의 프로퍼티를 만족시키기위헤
entry section, exit section에 코드를 넣어라

13)
3개의 프로퍼티를 애니메이션을 통해 설명해보자.

mutual exclusion
크리티컬섹션에 2개의 프로세스가 들어옴 -> 뮤추얼 익스클로전 프로퍼티 위배

이걸 보장하기위해
크리티컬 섹션앞에 엔트리섹션,
뒤에 엑시트 섹션에 코드를 넣는다

14)
해당 코드는 뮤추얼 익스클로전이 보장이 되었다.

15)
두번째 프로퍼티
결국 뮤추얼 익스클로전에 보장하기위해 엔트리와 엑시트에 코드를 넣는데,
코드를 잘못넣었어.
-> 크리티컬 섹션이 비어있음에도 불구하고 모든 프로세스가 웨이팅하고 있음.
-> progress property 위배

locking mechanism을 잘못쓴것.

16)
세번째
바운디드 웨이팅
p1 진입 -> p2 진입 -> p1 진입 …
=> p3가 계속 웨이팅함. 크리티컬 섹션에 언제 진입할지 모름..
-> 바운디드 웨이팅을 위배. (기다리는 시간에 upper bound가 있어야한다.)

—시험—
6장까지 + 과제

화 8시
목 7시 

