# OS 4주차-2

48)
다이렉트 커뮤니케이션, 인다이렉트 커뮤니케이텬

우선, IPC 메커니즘 크게 몇가지?
메세지패싱과 쉐어드메모리

- 다이렉트 커뮤니케이션 가장 큰 문제 -> 하드코딩. 리시버나 센더를 프로그램상에 직접적으로 넣어줘야함 -> 문제 발생.. 어떻게 그 이름을 먼저 알 수 있느냐? 이런 이슈 한정적임.
- 따라서 인다이렉트 커뮤니케이션이 일반적으로 많이 씅미 여기서의 link -> 메일박스.  인다이렉트 커뮤니케이션에선 옵션이 많음. 링크의 공유 측면에서. 메일박스를 통해 여러 프로세스들이 커뮤니케이션할수 있음(association) 또 2개의 프로세스간에 메일박스를 여러개도 둘 수 있다. 등.. 

49)
인다이렉트의 다양한 옵션 설명.

- a link = mailbox, 메일박스 하나에 여러개의 프로세스가 연결되어있음.
- 2개의 메일박스를 통해 p1과 p4가 통신

50)
인다이렉트 쓸려면 어떻게?

1. 메일박스 생성
2. 메일박스를 통해 send, receive수행
3. 필요없어지게되면 destory

51)
하나의 메일박스에 여러 프로세스가 연결되서 생길수 있는 문제
시나오리를 생각해보자.
![OS 4주차-2](images/OS%204주차-2.png)

이와 같은 시나리오. (A가 메일박스)
이럴때 어떻게할건데..?

해결책
- 메일박스 1개당 최대 2개만 연결시켜라
- 브로드캐스팅 (모두에게전송해라)
- 한명이 호출하면 나머지가 호출못하게. 특정시점에 특정프로세스만.
- 리시버를 선택하게 해라

52)
위 예시

=> 4개 옵션중 어떤거할것이냐?
응용프로그래머가 결정한다.

보통 ipc를 위한 primitive(=api)는 os가 제공하는데,
인자를 제어하므로써 컨트롤함. -> 이걸 응용프로그래머가

53)
또 하나의 옵션으로 생각할 수 있는것.
블락킹, 논블락킹

i/o나 메세지패싱같은경우 synchronous가 블라킹, asynchorounous가 non-blocking을 의미

54)
예시
블라킹 send를 보낼때 -> 블락됨 -> waiting 상태.
언제까지? A(메일박스)가 받은걸 확인할 때 까지

논블라킹 send는 전송하던말던 다음 line 수행

리시브도 마찬가지 옵션으로 설정가능.
리시브함수호출했는데 메일박스에 아무런 메시지 없음 -> 메세지가 올때까지 블락 -> 메세지가 메일박스에 전송이될때까지
논블라킹은 아무런메시지가없어도 다음라인수행.

질문, 블라킹 넌블라킹은 누가설정? -> 프로그래머가 설정. 메시지 패싱은 프로그래머가 프로그램 의도에 맞게 설정
단 os는 그걸위한 primitive를 제공하는 것뿐.

55)
조금 더 심화
노버퍼링(0 카파시티) 
 오토매틱 버퍼링

56)
정리.
핵심은 IPC 메커니짐을 구분하기
1. 메세지 패싱 센더와 리시버를 명시적으로 해야함 -> 메세지를 주고받을 받을때마다 시스템콜필요
2. 쉐어드 메모리 -> 처음 설정할때만 시스템콜필요, 그이후 커널의 도움이 필요없음 -> 속도 빠름 -> spin lock을 이용해서 동기화 메커니즘(쉐어드메모리를 보호해주는 메커니즘)을 구현해야하므로,  프로그래머 입장에선 쉐어드 메모리 구현이 조금더 어려울 수도

57)
정리2

4장시작
1)
4장은 쓰레드.

2)

3)
쓰레드가 왜필요하냐.

많은 케이스에선, 여러 프로그램들이 병렬적으로 수행될 필요가 있다.
대표적으로 서버프로그램.
여러 사용자에게 request가 오면 fork를 생성해서 요청을 처리하는데,
이 fork는 resource-intensive하고 시간이 오래걸린다.  부모의 address space를 duplicatie해야되고, pcb도 만들어야되고..등. 프로세스 통신해야되서 ipc도 필요, child runnable ….오버헤드가크다
그런데 어차피 요청을 처리하는코드는 같다.
->이 코드 데이터영역을 공유하자.
->code, data 영역을 복제할필요없다.
->코드, 데이터는 공유하고, 별도의 스택,레지스터는 가져야한다.

쓰레드 : 공유가능한건 공유하고, 공유못하는건 각자 가지자.

4)
위에 내용.

여러 오버헤드 요소들이 있다
=> 멀티쓰레딩
공유가능한건 공유하고, 공유못하는건(실행유닛) 공유못한다.

5)
지금까지우리가 배웠던건 실행유닛(executuion unit)이 하나였다. 왼쪽그림

멀티쓰레딩은 오른쪽그림. 공유할건 공유하자.
하지만 쓰레드(실행유닛)마다 별도의 레지스터, 스택이 필요

왼쪽같은경우는 서버에 요청이 들어올때마다 하나씩 다 생성해야하는데
오른쪽경우는 쓰레드만 생성하면됨. 오버헤드 감소

6)
장점.
1. 응답성이 좋다. 하나의 쓰레드가 block되더라도, 다른쓰레드는 working 시키면됨
2. 리소스 쉐어링 리소스 오버헤드 줄일수있다.
3. 프로레스 creation은 비용이 큰연산, context-swtich도 비용이 큰연산. 쓰레드를 사용하여 해결 훨씬 경제적인 오퍼레이션.
4. 최근의 멀티코어, 멀티프로세스 상황에서 효과적 왼쪼그림에선 cpu1, cpu3이 idle상태.. 하지만 오른쪽은 여러 cpu가 병렬적으로 일한다. -> 멀티프로세서 아키텍처를 효과적으로 운용

10)
지금까지는 하나의 프로세스, 하나의 쓰레드만 작동한다고 생각했는데, 이제 생각을 바꾸자.
여러개의 쓰레드..

11)
멀티코어환경에서 더욱 효과적

어떻게 병렬적으로 처리하느냐가 이슈.

1. 데이터 parallelism 아래의 그림예시. same operation을 분할해서 계산후 나중에 합산 -> 데이터 셋을 두개로 나눠 동일한 오퍼레이션을 실행한다.
2. 태스크 parallelism 쓰레드를 코어에 나누되, 각 쓰레드는 각 유니크한 일들을 수행

12)
Concurrent와 parallelism의 구분

-> 멀티코어시스템에서는 parallelism이 가능하다.
싱글코어는 concurrent가 지원이되는것

13)
멀티코어프로그래밍 어렵다.
- task 할당
- 코어간의 밸런스 고려

	=> 두개다 os가 함
- 데이타 스플리팅
- 데이타 의존성(a->b로 진행되어야하는 프로그래밍이 존재하는데, 동시에 수행할수 없잖아.)
- 테스팅 디버깅

질문**
싱글코어에서 쓰레드는 어떤의미를 가지나. 어차피 1개만 실행되는데
예)
A라는 프로세스의 쓰레드 5개
B라는 프로세스의 쓰레드 2개
자원공유 측면에서 의미가있고
쓰레드 가지고 스케줄링하는데, A에게 5번, B에게 2번 스케줄링한다는데서 의미가 있다.

*****

14)
위에 오타, three가 아니라 two

쓰레드의 종류
생성하는 주체가 누구냐에 따라.
- 커널쓰레드 -> 커널이생성
- 유저쓰레드 -> 유저가생성

15)

16)
예시.
쓰레드의 이해

유저 쓰레드 5개있고, 커널쓰레드가 2개있다

유저 쓰레드는 커널쓰레드에 mapping되어있다.

1. 스케줄러는 유저쓰레드의 존재조차 모름

유저쓰레드가 수백개생성되도 스케줄러는모름. 
커널쓰레드가 몇개있느냐만 파악. 유저쓰레드는 커널쓰레드에 어떻게 매핑도 그런거 모름.
-> 별도로 스케줄링 되는 것은 커널이다

 2. UA가 disk i/o를 함 -> 그래도 커널은 ka가 한걸로암 -> ka를 waiting 상태로 -> UB, UC는 덩달아서 블락됨

1. 별도로 프로세서나 코어에 할당되는 개체는 커널쓰레드 이다.

17)
1번 시나리오
스케줄러는 ka, kb만 바라봄
스케줄러가 관여하는 쓰레드는 커널쓰레드다. 할당시키는것.

그 커널쓰레드가 실행될때, 그커널쓰레드와 매핑된 유저쓰레드가 실행된다.

18)
2번 시나리오
UA가 disk i/o를 한다?
-> 커널은 Ka가 disk i/o를 했다고 생각.
-> Ka와 매핑된 모든 유저쓰레드 블락.

19)
3번 시나리오
하나의 프로세서에 하나의 커널쓰레드가 할당

20)
멀티쓰레딩모델 3가지

앞에가 유저쓰레드, 뒤에가 커널스레드
many to one : 여러 유저쓰레드에 커널쓰레드 하나
one to one : 유저쓰레드하나에 커널쓰레드 하나
many to many

21)
many-to-one model

빠르고 오버헤드적다 
-> 유저 쓰레드를 생성하는 개체는 쓰레드 라이브러리다.
커널쓰레드처럼 시스템콜로 쓰레드만들려면 시간 오래걸리는데, 라이브러리에서 쓰레드만들면 쉽게만듬

문제
1. 한쓰레드가 블라킹 시스템 콜을 하면 나머지도 블라킹
2. 멀티프로세서의 병렬젹 수행에 있어서 효과를 볼 수 없음.

22)
one-to-one 모델

유저쓰레드 하나당 커널쓰레드 하나.

매니투원보다 오버헤드가 많다. 더느리다.
유저쓰레드 만들때마다 커널쓰레드 만들어야하니까.

하지만 매니투원의 문제들 해결.

참고)) 요즘은 거의 원투원씀. 

