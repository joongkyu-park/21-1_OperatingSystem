# os 5주차-1

지난시간복습하면서 시작.
16)
커널스레드와 유저스레드의 개념을 파악해야 
멀티스레딩을 제대로 파악할 수 있다

커널스레드 : 커널에서 생성된 스레드
유저스레드 : 유저라이브러리에서 생성된 스레드

스케줄러도 커널에있고, cpu할당하는것도 커널에있고

이슈3개.
무엇?

17)
이슈1.
스케줄러는 유저 스레드의 존재를 모른다.
-> 커널스레드를 스케줄링함 -> 해당 커널스레드와 매핑된 유저스레드중 하나가 실행이 된다.

18)
이슈2.
UA가 디스크io
-> UA가아니라 ka가 waiting 스테이트로 전환
-> 이거와 매핑된 모든 유저스레드가 블락된다.

19)
이슈3.
cpu할당도 커널스레드가함
커널스레드 하나에 프로세스 하나

20)

21)
프로세스내에 커널스레드가 하나있는것.
그위에 매핑된 유저스레드는 여러개 있을 수 있다.

1. 빠르다, 오버헤드가 적다. 유저스레드가 유저라이브러리에서 생성된다. -> 커널이 관련하지 않으니까 빠르고 오버헤드적을 수 밖에
2. 유저스레드 1개가 블락킹 io를 하면 전체 유저스레드가 블락킹됨. 왜냐하면 커널스레드가 waiting state가 되니까
3. 멀티프로세스 환경에서 parallel하게 운용 불가. 프로세스 하나당 커널 스레드 하나가 할당되니까.

22)
이게 요즘 리눅스나 윈도우즈에서 쓰는 모델.
유저 스레드 1개당 커널스레드 1개 생성하므로 자원이많이들고(resource-intensive) 상대적으로 느리다.
but, 위의 문제를 다 해결가능.

23)
원투원모델과 매니투매니방식을 하이브리드 방식 방식.

이슈는?
Multiplexing이 필요
멀티플렉싱 : 유저스레드가 실행되려면 -> 어떤커널스레드에 매핑이 되어야한다.
	-> 그것을 결정하는 것이 멀티플렉싱
커널스레드 개수는 유저스레드 개수보다 같거나 작다.

매핑시켜주는게 Multiplexing

24)
장점3개.
1.유저스레드를 필요한 만큼 생성가능
2.멀티프로세서에서 커널스레드가 병렬적으로 수행가능
3.유저스레드 A가 블락킹 시스템콜을 한다. (A,B가 같은 커널에 매핑된 상황)
	-> 멀티플렉싱을 바꾸어주어서 B를 다른 커널에 매핑시켜준다!
	-> B 블락안된다
	-> Scheduler Activation

단점은 멀티플렉싱이 필요하다는거 자체가 복잡함. 구현 오버헤드가 있다.

25)
투레벨 모델.
매니투매니모델 + 원투원 모델

이때 원투원모델들 선택한것을 bound thread라고 명칭을 붙인다.

26)
결국에는 리눅스, 윈도우즈 계열은 원투원 모델을 쓴다.

실제 리눅스에서 쓰레드를 관리하는지 설명

프로세스 B는 스레드 2개
C는 쓰레드 여러개.

**키아이디어
-> 유저쓰레드가 생성될
-> 별도의 PCB를 할당해주는 것. task_struct 구조체의 PCB(3장내용)
-> PCB가 있다는 소리는스케줄러관점에선 별도로 스케줄링 하는 개체가 되는것. 서로다른 코어에 할당될 수 있는 개체라는 뜻.
-> 이와같은 점에서 원투원모델을 사용한다고하는 것

앞의 개념얘기와 실제 얘기가 다른점.
커널스레드가 생성이 되긴한다만 유저스레드와 매핑안됨
커널스레드와는 실제로 매핑x (앞서 얘기했던 모델링과는 조금 다름)
실제로의(리눅스에서의) 커널스레드의 개념은 
커널자체에서 해야될일을 수행(백그라운드 일들이 많음)하기 위해서 커널스레드를 생성

clone이라는 함수는 posix에서 쓰이는게 아니라 리눅에서만 쓰이는 모델이다.
clone이라는 함수를 통해 리소스 쉐어, 즉 공유정도를 굉장히 세분화하여 컨트롤가능.

27)
쓰레드 라이브러리

사용자가 api를 호출해야한다. 그것을 위한 라이브러리

2가지옵션
1. 라이브러리를 전체적으로 유저스페이스에서 호출하느냐, 제공하느냐 -> 유저스페이스에 한정되있기때문에 시스템콜로 연결되지않음
2. 그거와 연관된 커널레벨 라이브러리를 구현해야하느냐 -> os로부터 직접적으로 지원받기때문에 시스템콜을 호출함

리눅스로 같은 경우.
p_thread 함수 호출 (쓰레드생성)
-> pcb 생성
-> 2번 (시스템콜 호출)

28)
스레드 라이브러리 보자

- 포식스 라이브러리 리눅스에선 커널레벨로 지원 (원투원모델이니가) 다른 유닉스 계열에서는 유저레벨로만 지원될 수 있음
- 윈32 스레드 원투원모델이므로 -> 커널레벨라이브러리
- 자바 스레드 그 밑에 어떤 시스템이 쓰이느냐에 따라 쓰레드 라이브러리가 달라진다. host system에 따라 달라짐. ( 그 호스트 시스템에서 제공되는걸 쓰기 때문)

29)
pthread 라이브러리 함수를 쓰는 예.

1. phtread_attr_init 함수를 호출해야함 쓰레드의 attribute, 즉 속성을 설정해주는 함수 인자를 넣어줄 수 있다. null 값이 디폴트. 인자로 그 스레드의 스케줄링 방식이라던가.. 등등 속성을 세세하게 설정가능
2. pthread_create 스레드 생성 -> 리눅스에서 이 스레드를 위한 pcb 생성 -> 그 때부터 별도로 수행 코드에서는 runner라고하는 함수가 스레드로 생성이되서 pcb를 가지고 개별적으로 실행
3. pthread_join wait 함수와 유사. 생성된 스레드가 runner함수인데 runner함수가 끝나길 기다린다. 해당 라인에서 블락된다. 블락이 풀리려면 runner에서 pthread_exit함수고 호출되고 종료되면 블락이 풀리고 다음라인 실행.

30, 31)
스레딩 이슈

스레드는 리소스를 쉐어하기때문에 다양한 이슈가 있을 수 있다.

스레드 내부에서 fork가 호출됨 (위에서 runner라는 함수 내에서 fork가 호출된것)
-> address space 듀플리케이션
-> exec으로 새 프로그램 로드 하는 방식인데,

콜링 스레드뿐만아니라 피어스레드, 즉 프로세스의 모든 스레드를 듀플리케이션할것이냐
	-> exec 호출되지 않는 경우.
콜링한 스레드만 듀플리케이션할것이냐
	-> exec 호출되는 경우. 어차피 overwrite될거니까 굳이 전체 듀플리케이션 x.

32)
두번째 이슈
thread cancellation

대표적인 예
웹브라우저에서 홈페이지에 접속할 때
광고도 뜨고, 플래시동영상도 플레이되고.. 이런것들이 복잡하게 되어있는데
-> 이것들도 다 별도의 스레드로 되어있는 거.
웹브라우저창의 x 버튼을 누르면 -> 다른 스레드들의 작업(영상 등)끝나기전에 터미네이션하는것
-> 이때 어떻게 할것인가.

즉 프로세스위에 여러 쓰레드가 동작하는데, 하나가 종료되면
나머지 쓰레드(=target thread)를 어떻게 할것이냐.

-> 타겟스레드를 같이 종료시킨다.
= Asynchronous cancellation, 위의 웹브라우저같은 예

그러나 어떤경우는 종료를 안시킬 수 있다.
= Deferred cancellation, 종료를 뒤로 미루는 어프로치를 사용

33)
터미네이션되는 스레드와 타겟스레드

Asynchronous cancellation -> 타켓스레드를 동시에 종료

Deferred cancellation -> 타켓스레드를 종료해도되는지 check를 하다가, 
			-> 종료시켜도 safe하다 하면 그 때 종료

34)
시그널 핸들링 관점에서는 어떻게 되느냐.

시그널, 신호.
시그널 왜 쓸까. 프로세스에게 이벤트가 발생된것을 알려주려는 notification 메커니즘.
프로세스에게 뭔가 알려줄때.

시그널 종류 2종류
synchronous signal - 내부적인 문제들에 관한것, 즉 Execption
asynchronous signal - 프로세스 외부에서 발생한 시그널

시그널이 발생했을때, 시그널을 처리하는 핸들러가 있음.
시그널핸들러는 이미 디폴트로 구현되어있는 것도 있고,
사용자가 define하는 시그널 핸들러도 있다.

35)
시그널이 발생할때, 스레드가 여러개있어서 다양한 옵션이 있을 수 있다.

1. 시그널이 적용되는 스레드에게만 시그널을 전송?
2. 모든 스레드에게 전송?
3. 특정 스레드에게 전송?
4. 그 시그널이 적용되는 specific한 스레드를 지정할것이냐 -> phtread_kill이라는 함수를 통해. (kill, 즉 termination하라는 소리아님 ㅎㅎ) 프로그래머가 시그널을 받는 스레드를 명시할 수 있다. 첫번째인자 스레드아이디, 두번째인자 시그널번호

에)
0으로나누는 연산
-> 1번옵션
ctrl + c (터미널창에서 종료할떄)
-> 2번옵션

36)
이해를 위한 애니메이션.
0으로 나누는 연산을 code부분 스레드가 발생시킴
-> 시그널이 해당 스레드에게만 전송

컨트롤 c버튼
-> 모든 스레드에게 시그널을 전송해야한다.

=> 시그날에 따라 어느 스레드에 전송할것인지가 결정된다.

37)
스레드 풀.
원투원 모델을 생각해보자.
유저쓰레드 생성 -> 커널 스레드 생성

프로세스 1개가 있는데, 프로세스에서 커널생성에서 계속 생성(pthread_create함수)..
-> 뭐가문제가 될까
-> 프로세스 하나가 너무많은 리소스를 사용하게 된다.
-> 시스템 리소스를 exhaust하게 된다.
그래서 나온게 스레드풀

1. 하나의 프로세스내에서 제한된 스레드 개수만 생성가능 (시스템 리소스 Exhaust 막기위해_
2. 풀에 몇개의 스레드를 미리 생성해놓고 (빠르게 스레드를 생성하기위해)

이 2가지 모티베이션.

장점.
-create하지않고 기존에 있는 스레드를 사용하기 때문에 빠름
-제한된 사이즈의 스레드를 생성하므로 리소스 Exhaust 방지

즉, 스레드마다 이 풀을 가지고있다는 뜻.
그 풀에서의 생성된 스레드의 개수가 이미 결정되있고, 그것만큼 사용할 수 있는것.

38)
예.
풀이 3개의 스레드를 미리 생성해놓았다.

스레드를 사용하려는 요청이왔다 -> 스레드를 바로 가져다씀 -> 빠르다

풀에 있는 스레드 개수 이상의 요청이들어오면, 요청을 거절하거나 기다리게한다.

39)
스레드 specific 데이터
특정 스레드만을 위한 데이터를 둘 수 있다.

스레드에서 공유되는것 - 코드, 데이터, 파일들이 공유
각각 스레드가 자기만의 데이터 영역을 두어서 사용할 수 있다.
스레드 라이브러리에서 지원해준다.

