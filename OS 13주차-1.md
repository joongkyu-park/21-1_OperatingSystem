# OS 13주차-1

13~15장. 새로운 토픽. 파일시스템

2)
아웃라인
 
3)
파일의 정의
관련된 정보들을 secondary storage에 이름지어 모아둔것

파일의 속성
…

4)
파일 오퍼레이션
파일 접근을 위한 함수이다. 
사용자들에게는 필요없는 함수이다. 윈도우 탐색기를 이용하니까

이 함수들도 os에 접근하므로 시스템 콜이다.
파일포지션 포이터를 이용
![OS 13주차-1](images/OS%2013주차-1.png)

*파일오픈은 여러 응용프로그램에서 어쩌구*
5)
파일 open에 대해서.

파일시스템 관련해서 중요한 역할

오픈파일테이블. 오픈한 파일에 대한 리스트에 정보를 테이블형태로 관리.

파일오픈을하면 파일디스크럽터(fd)리턴. 리숙

오픈하게되면, 오픈파일테이블에 우리가 읽는 파일들에 대한 정보가 증가. 테이블의 엔트리가 증가. 닫으면 사라지겠다.

오픈하는 이유 : 파일에 대한 read, write를 효과적으로 진행하기 위해서
이를 오픈파일테이블을 리턴하여 리드, 라이트를 효과적으로 수행

오픈파일테이블에는 파일의 디렉토리를 저장한다.
파일 오픈에 성공하면, 오픈파일엔트리( = 파일디스크립터) 를 리턴

![OS 13주차-1-1](images/OS%2013주차-1-1.png)

6)
읽는 정보들

파일포인터 : 현재 파일의 위치
파일오픈카운트 : 오픈된 파일들에 대한 카운트
…

오픈파일은 나중에 다시한번 자세히 설명

파일을 오픈하는 이유는 중요한 정보들을 메모리로 올려놓고
그 정보를 참조해서 read, write를 효과적으로 수행.
그 정보들을 파일포인터, 파일오픈카운트, 디스크에서의 파일의 위치 등.
이것만 기억

7)

8)
4가지 인포메이션을 이용하여 read, write를 효과적으로 진행

제일 중요한것은 해당 파일이 스토리지 어디에 저장되어있는지.
스토리지는 블락으로 나누는데, 블락의 크기는 4KB이다.
ex) 4MB파일 -> 1024개의 블락, 4GB -> 1024 * 1024개
이런 무수한 블록들이 스토리지에 연속적으로 저장된다는 보장이 없다.
-> read, write를 하려면 이 블락의 위치들을 다 기록을 해야한다.

엄청나게 큰 디스크의 몇번째 블락에 파일의 블락이 위치해있다. 를 어떻게 알까
-> FCB(File Control Block) 즉 inode라고 불린다(유닉스 계열에서)
그 파일의 모든 블락의 번호가 기록되어있다. 이외에도 파일의 속성, 생성날짜 등 모든 정보

따라서 파일의 inode만 찾으면 파일을 구성하고 있는 모든 블락의 위치, 모든 정보를 알 수 있다.
따라서 핵심은 inode, 즉 FCB이다.

어떻게 하면 inode를 가져와서 확보할 수 있을 것이냐 초점.
-> Directory structure 개념을 이용.

Directory structure는 디렉토리이다.
디렉토리를 만드는 기본적인 이유가 뭘까? (/abc/user/hi  …)
우선 사용자 관점에서.
파일의 분류, 정리를 위해.
한 디렉토리내의 2개의 동일한 파일name을 넣을 수 없다. 파일충돌문제 등
OS관점. 파일시스템 관점.
디렉토리 스트럭쳐. 결국 그냥 우리가 알고 있는 디렉토리인데,
디렉토리 하위에 있는 모든 파일들에 대한 정보를 가지고 있다.

inode를 가져오는게 있는데, 디스크에 파일들이 굉장히 많으니까,
inode를 가져오는데 핵심적인 역할을 하는것이 디렉토리 스트럭쳐.
하위의 파일들에 inode를 가져오는 힌트가 디렉토리 스트럭쳐가 들어있다.
os는 inode를 가져오기 위해 디렉토리 스트럭쳐를 lookup한다.

9)
부트 컨트롤 블락.
시스템을 부팅할 때 필요한 정보를 담고 있다.

윈도우와 유닉스는 전혀다른 파일시스템을 사용한다.

10)
볼륨 컨트롤 블락.
파일시스템 자체에 대한 정보를 가지고있다.

볼륨은 partition을 의미한다. c드라이브, d드라이브 …
별도의 드라이브(파티션)에서는 별도의 파일시스템이 들어갈 수 있다 -> O. 이게 핵심.
파티션을 나누는 이유는 파티션 별로 별도의 파일시스템이 있을수 있다. 이것이 볼륨

왜 A, B파티션은 없을까. 처음에 C드라이브잖아.
플로피디스크 그런것들이 A, B 드라이브 였다.

그 파티션에 대한 정보를 담고 있는 데이터 스트럭쳐가 볼륨컨트롤블락. 파일시스템 자체에 대한 정보)
파티션의 블락수는 얼마고, …. 등등
-> 매우 중요한 정보기 때문에 superblock(=볼륨컨트롤블럭)이라고 부른다.
이게 날라가면 쉽지않다..
superblock은 보통 워낙 중요하여 정보의 보존을 위해 중복하여 저장한다. 스토리지가 은근히 고장이 잘 발생한다.. 그러므로..!

디렉토리 스트럭쳐.
파일 이름과 관련된 inode넘버들이 들어있다.
파일시스템 입장에서는 inode를 확보하기 위해 이 디렉토리 스트럭쳐를 룩업해야한다.
왜냐하면 inode에는 파일에 대한 거의 모든 정보가 담겨 있기 때문.

inode 테이블은 array형태로 관리하여 쉽게 가져올 수 있다.

11)
FCB에 대해선 나중에.

중요한 것은 inode!
read-write를 하려면 디스크 내에 그 파일의 위치를 알아야하는데, inode에 정보가 있다.

12)
지금까지 4가지 데이터 스트럭쳐에서 배웠다.

메모리에서 항상 관리해주는 데이터 스트럭쳐가 있다.
1. In-memory mount table
파일 시스템을 사용하려면 반드시 mount를 해주어야한다.
드라이브마다 별도의 파일시스템이 있으니까, 이러한 마운트에 대한 정보를 In-memory mount table에서 담고있다.
요즘에는 마운트가 자동으로된다. usb 꽂으면 파일시스템을 인식하고, 파일시스템이 있다면 마운트가 자동으로.

윈도우와 다르게 유닉스는 임의의 디렉토리에 마운트가 가능하다는 특징.

2. In-memory directory structure
inode에 대한 정보들을 가지고 있다.

오픈된 파일은 2개로 분류하여 관리
3.System-wide open-file table
오픈된 파일들에 대한 정보를 가지고 있다.

4. Per-process open-file table
이것을 별도로 두는 이유. 
![OS 13주차-1-2](images/OS%2013주차-1-2.png)

예를들어 3개의 어플리케이션이 A라는 파일들 동시에 읽었다면,
현재 읽는 file position pointer가 어플리케이션마다 다르다.
app1은 파일 처음부터 읽고, app2는 파일 중간부터 읽고..

여튼 별도로 프로세스마다 관리해야할 정보들이 있고(파일포지션포인터),
A라는 파일 자체에 대한 정보(inode), 즉 전체적으로 관리해야할 정보가 있기 때문에
오픈된 파일에 대해 2가지로 나누어서 관리.

![OS 13주차-1-3](images/OS%2013주차-1-3.png)

13)
시스템 와이드 오픈 테이블
FCB에 대한 정보는 디렉토리 스트럭쳐를 통해 정보를 가져온다.

퍼 프로세스 오픈 테이블
file offset = file position pointer

14)
스텝바이스텝으로 어떻게 파일을 오픈해서 리드하는지 살펴보자.

파일이 오픈이 된다.
파일시스템에서 하는일
1. 시스템 와이드 오픈 파일 테이블을 서치. 이미 열어 놨을 수도 있으니까. 이미 다른 어플리케이션에 의해 사용되고 있을 수 있으니까.
-> Ok이면, 이미 다른 프로세스에 의해 오픈이 된것이므로, 퍼 프로세스 오픈 테이블을 따로 생성하고, 이걸 가르키면된다.
-> 없다면, inode를 통해 FCB을 확보해야한다. FCB을 확보하고 시스템 와이드오픈파일 테이블에 카피하여 놓는다. 그리고 퍼프로세스 오픈파일 테이블을 따로 만든다. 확보하기 위하여 디렉토리 스트럭쳐를 서치, lookup 해야한다.
자주 access되는 디렉토리 스트럭쳐는 메모리에 있을 수 있다.

그리고 FCB이 시스템와이드오픈파일테이블에 카피된다.

15)
read, write
FCB이 있는 상태. 그 디스크의 파일의 위치, 등등에 대한 정보 다 가지고 있음.
FCB를 통해 디스크에 어느 파일이 위치 했는지 알 수 있다면, read-write를 진행할 수 있다.

16)
그림으로 설명

17)
파일이 closed 될 때

1. 퍼 프로세스 파일 테이블 삭제.
2. 오픈 카운트 하나 감소. 오픈 카운트가 = 0 -> 어떤 프로그램도 해당 파일을 오픈하지 않은거니까 시스템와이드도 제거

18)
유닉스 기반에서 어떻게 관리하는지 설명.

19)
결국에는 inode, 즉 메타데이터를 확보하는게 핵심.
FCB에는 파일에 대한 거의 모든 정보가 있다.
리드-라이트하기 위한 디스크에서의 위치부터..

20)
inode를 어떻게 찾아? -> 디렉토리 스트럭쳐럴 룩업.
![OS 13주차-1-4](images/OS%2013주차-1-4.png)

디텍토리 스트럭쳐는 다음과 같이 저장.
하위에 있는 파일네임-아이노드 를 알 수 있음.
어레이 인덱스만 알면 inode를 가져올 수 있기 때문에

22)
그림으로 보자.

root 디렉토리(inode 2번)부터 시작한다.
2번을 뒤져봤더니 루트디텍토리의 위치를 알 수 있었다.
os가 디렉토리 스트럭쳐를 읽을 수 있다.
그 밑에 있는 디렉토리에 대한 모든 파일의 정보를 가지고 있으므로,
-> usr 디렉토리를 읽을 수 있다. inode 4번을 찾음으로써.
-> a.txt를 읽을 수 있고
시스템와이드에 해당 파일의 inode를 가져다놓고, 이후로는 리드-라이트가 손쉽게 이루어진다.

23)
버츄얼 파일 시스템
![OS 13주차-1-5](images/OS%2013주차-1-5.png)

서로 다른 회사의, 이질적인 파일시스템을 읽을 수 있다.

각각의 파일시스템마다 별도의 오픈, 리드 .. 함수 등이 있을 건데 어떻게 가능?
-> 버츄얼 파일 시스템을 쓰기 때문

24)
동일한 시스템콜 인터페이스를 써서 서로 다른 파일시스템에도 적용하게 하도록 반드시 버츄얼 파일시스템이 중간에 있어야한다.

응용프로그램 단에서 우리가 호출하는 오픈, 리드 등의 함수는 VFS의 API이다.
실제 특정 파일시스템의 API가 아니다.

VFS입장에서는 하부레이어의 모든 다른 파일시스템을 관리하는데,
각각의 파일시스템마다 inode 테이블이 있을 것인데, 해당 테이블을 각각 별도로 관리해야할 것이다.
즉 A 파일시스템에서 inode 1번인 파일과, B 파일시스템에서 inode 1번인 파일은 당연히 각각 다른 파일일 것이다. 이를 어떻게 관리할까
-> Vnode
각각 유니크하게 관리하기 위해 Vnode를 통해 전체 inode를 관리한다.
![OS 13주차-1-6](images/OS%2013주차-1-6.png)

