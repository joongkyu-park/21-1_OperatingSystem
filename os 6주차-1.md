# os 6주차-1

지난 시간에 이어서 5장내용 진행.
스케줄링 알고리즘

21)
첫번째 알고리즘
First Come Fist Served(FCFS)

(간트차트
특정시간에 어떤 프로세스가 수행되는지 보여주는 바 차트

간트차트로 어떻게 스케줄링되는지 잘 보자.)

먼저온 태스크가 먼저 수행된다.
	
p1 p2 p3 순으로 도착 -> 도착한 순서대로 수행

저번시간에 얘기했던,
스케줄링 criteria중 가장 중시하는 거 criteria
-> 에버리지 웨이팅 타임

여기서 에버리지 웨이팅 타임 계산하면 17.

22)
이번엔 도착순서가 p2,p3,p1

에버리지 웨이팅 타임 3

-> 동일한 스케줄링 알고리즘(FCFS)을 사용함에도 불구하고
에버리지 웨이팅 타임 편차가 매우 크다.

도착 순서가 중요 -> 운이 중요
가장 큰 이슈가 variation이 크다.

Convoy effect
먼저 온 태스크가 오랜기간 수행해서 뒤에 있는 태스크가 오래 기다리는 현상
즉 긴 프로세스가 먼저 수행되고 짧은 프로세스가 나중에 수행되는 현상
21)의 예에서 컨보이 이펙트 발생.
-> 에버리지 웨이팅 타임의 증가

23)
Shortest-job-first (SJF) 스케줄링
각 프로세스의 cpu burst시간을 파악해서
-> 가장 짧은 job에게 우선순위를 준다.

두 가지 버전 이있음
- nonpreemptive preemption이 안됨 예) a라는 태스크가 수행중(가장 짧은 태스크, 수행시간 5) 한 2정도 수행했을 때, 태스크의 길이가 2인 b 태스크 들어왔다. -> 그 시점에서 원칙상 shortest job은 b이지만, 하지만 a가 끝낼때까지 계속 진행
- preemptive 위의 상황 똑같을때, -> 그 시점에서 a의 수행 멈추고 b 먼저수행  기존의 수행되는 태스크의 남아있는 시간과 비교하게 된다, => Shortest-Remaining-Time-First (SRTF)

SJF 스케줄링은 에버리지 웨이팅 타임을 줄인다는 측면에서 최적이다.
그중에서도 SRTF

24)
왜 SJF가 최적인지
에버리지 웨이팅 타임과
에버리지 턴어라운드 타임(끝나는시간)

가중치가 높은 순서(la->lb->lc->ld)순으로 값이 작아야 최종결과가 최소가 된다.

25)
예제
nonpreemptive
0의 시점에 레디큐에 p1밖에없음
2의 시점에 p2가 들어왔지만 preemption이 안되므로 계속진행

26)
preemptive
프로세스가 도착하는 시간마다
수행중인 프로세스의 남은 시간과 레디큐의 기다리는 프로세스의 시간들을 비교해
가장 짧은 태스크 먼저수행

여기서 에버리지 웨이팅 타임 계산은?
(웨이팅 타임 : 큐에서 기다린 모든시간
리스폰스 타임 : 처음 시작하기 전까지 시간)

웨이팅타임
p1 : 2~11까지 레디큐에서 기다림. 9
p2 : 4~5, 1
p3: 0
p4: 5~7, 2

=> preemptive이 에버리지 웨이팅타임 측면에서 더 좋다.

	
27)
하지만 impratical함.. (아직 수행안했는데 cpu burst 시간 어떻게 알아)

따라서 미래의 수행시간을 예측하자.
-> exponential averaging. 상당히 합리적인 예측 기법
기본아이디어)
1. 이전의 수행시간을 바탕에 기반(previous CPU burst)
2. 최신 cpu burst에 가중치를 높게 둔다.

28)
exponential averaging 수식
![os 6주차-1](images/os%206주차-1.png)

전개해보자. 점화식을 풀어보자.

지금이 n이라고 했을때
τ n+1 : 다음시간에서의 예측시간. 
t n :  n번째턴에서의 수행시간(과거)
τ n : n번째의 예측시간 

α = 0 -> 최신 히스토리 반영 x
α = 1 -> 바로 이전에 수행되었던 시간으로 예측
=> 이 α을 적절히 선택해야한다.

전개과정은 다음슬라이드에서.

29)
α는 0 <= α <= 1 의 값
![os 6주차-1-1](images/os%206주차-1-1.png)

각 tn의 가중치를 보면, 최근 히스토리에 가중치를 높게 둔다.

30)
α가 1/2일 경우

-> 최신 히스토리에 가중치를 더 높기준다

31)
또다른 예시를 통해~
α = 1/2 가정

*
여기서 말하는 건
하나의 프로세스 내의 히스토리임.

프로세스의 일생이
![os 6주차-1-2](images/os%206주차-1-2.png)

이렇게 되는데
싱글 프로세스 내에서 다음 cpu burst의 시간을 예측하는것.

32)
세번째 스케줄링 알고리즘
priory 스케줄링
각 프로세스마다 우선순위 넘버를 할당
숫자가 작으면 우선순위가 높고 무조건 넘겨줌

여기서도 
preemptive, nonpreemptive 2가지 존재

문제)
starvation -> 오랜기간 수행이 안되는것. 계속 blocking되서. 우선순위가 낮으면..

솔루션)
Aging 기법.
기다린 시간이 늘수록 우선순위 점점 올려줌

33)
aging 기법 예시
![os 6주차-1-3](images/os%206주차-1-3.png)

34)
프라이오리티 스케줄링 종류
- 스태틱 프라이오리티 우선순위 안바뀜
- 다이나믹 프라이오리티 우선순위 바뀔 수 있음 -> 에이징 기법은 여기 속함

35)
Round-robin scheduling
키워드 : 번갈아 수행하자.
time quantum만큼 수행하고 번갈아 수행하자.

당연히 preemptive scheduling
타임퀀텀만 만큼 수행하고 preemption이 오토매틱하게 일어나겠다.

n개의 프로세스가 있다면 레디큐 마지막에 있는 프로세스는 (n-1)번의 타임퀀텀을 기다려야하겠다.
-> 최대 (n-1) x 타임퀀텀 만 기다리면됨.

타임퀀텀 어떻게 정할까.
q가 너무 작다 -> 컨텍스트 스위치 오버헤드 크다
q가 너무 크다 -> 라운드로빈스케줄링은 fairness(공평함)을 강조한 스케줄링 기법인데,
		q값을 늘리면 fairness가 상대적으로 저하된다.
![os 6주차-1-4](images/os%206주차-1-4.png)

36)
예시
time-quantum이 20

라운드 로빈의 response time은 좋다.
번갈아가면서 일단 수행이 되기 때문에. SJF보다 더 좋다.
하지만 웨이팅타임은 SJF가 최적

37)
컨텍스트 스위치 오버헤드에 대한 예시

퀀텀과 컨텍스트스위치가 트레이드오프 관계에 있다.

38)
Multilevel Queue
레디큐가 클래스별로 여러개로 분할되어있음.
각각의 프로세스는 자기가 속한 큐가 있음.
-> 큐 안의 스케줄링 알고리즘이 있음, 그리고 큐간의 스케줄링 알고리즘이 있음

마치 월드컵.
asia, europe… 같이 각각의 클래스가 있다.
특정 프로세스는 특정 클래스에 속해있다.

그래서 큐안에서 스케줄링한다음에 각각의 대표를 뽑아서
큐간에 스케줄링으로 그 대표중에 또 하나를 뽑음.

39)
예

여기선 큐간의 스케줄링을 priority 스케줄링으로 함.
하지만 반드시 이러는건 아님.

——
질문)
SJF에서 p1, p2, p3 … 의 cpu burst의 길이가 달랐는데,
	-> 이건 다른프로세스. 우선순위가 가장 높은 프로세스를 선택하는 기법
exponential averaging에서 처럼 p1, p2, p3 .. 가 각각 다른 프로세스가 아니라
같은 싱글프로세스 내의 cpu burst인가요?
	-> 이건 싱글프로세스에서 다음 cpu burst를 예측하는 기법

