# os 2주차-2

39)
듀얼모드(커널모드,유저모드) 목적?
os만 접근할 수있는 컴퓨터 하드웨어를 응용프로그램이 수행 못하도록

핵심은 protection.
방법은 privileged instructions -> 커널모드에서만 수행하도록

유저모드, 커널모드 구분 방법-> 비트로 구분

유저모드와 커널모드를 번갈아가면서 수행. (context switch)

40)
앞으로 배울것

- process management -> multitasking
- memory management -> virtual memory
- .. (스크린샷 확인)

41)
3장에서 배울것
프로세스(process)의 정의
: program in execution : 현재 수행중인 프로그램

context switch(프로세스가 번갈아가면서 수행) 되면서 프로그램 수행중
커널모드, 유저모드 계속 왔다갔다 하는중
단 우리가 인지를 못하는 것 뿐. 내부에서는 그렇게 동작중.

42)
4장, 쓰레드
프로세스와 연관된 오버헤드를 줄이기위해 쓰레드란 개념이 나왔다.

5장, 스케줄링
스케줄러가 하는것
프로세스가 많이있음. cpu는 하나.
저 많은 프로세스중에 1개를 선택해야함, 아주 짧은 매 순간마다.

cpu나 코어가 여러개 있다면 할당까지 고려해서 스케줄링이 되어야함
따라서 멀티cpu에서 allocation까지 어떻게 하냐, 도 배운다

43)
6~7강, Synchronization
멀티태스킹이기때문에 여러개의 프로세스가 동시에 수행중.
여러 프로세스들 간에 동기화를 해줄 필요가 있다. -> 싱크를 맞출 필요가 있다.
여러 프로그램들이 협업할 기회가 많이 있기때문에 싱크를 맞추어야한다.
협업이 올바르게 이뤄지지않으면 race condition이 일어날 수있다
wrong result가 나오는것. 3+2=6 이렇게 나오면 안되잖아!
-> ⭐️semaphore, ⭐️critical-section 을 사용해라. 아주 중요한개념. 면접에서도 단골문제

8장, 데드락
synchoronization을 잘못해서 데드락이 발생할 수 있음.
프로그램이 아예 멈춰버리는것. 절대 막아야함

44)
메모리 매니지먼트가 필요한 궁극적인 이유?
-> virtual address 때문에~~
왜 가상메모리 쓰냐?
-> 당연히 공간을 넓게 쓰기 위해서

(스크린샷)과 같이 포인터변수 a를 출력하면 나오는 주소는
1. 가상주소? 2. 물리주소? => 가상주소가 출력된다. 프로그램에서는 가상주소를 쓴다.

45)
9장
address translation이 빠르게 일어나야한다.
라인 바이 라인으로 translation을 해야하는데…
어떻게 빠르게?
=> 하드웨어의 도움을 맞는다. MMU (Memory Management Unit)

46)
10장
결국 Virtual공간이 Physical공간보다 크다

swapping in, swapping out이 적절히 일어나야함.
그런데 누구를 out시킬것이냐. 에 대한 알고리즘을 배우낟
=> LRU 알고리즘.(Lesat Recently Used) : 가장 최근에 안쓰인.

47)
11장, storage

NVM(non volatile memory)은 비휘발성메모리를 총칭한다고함. SSD라고 생각.

스토리지는 제일 느리다.. 메모리는 빠르다, cpu는 매우빠르다

컴퓨터전체는 제일 느린시스템인 스토리지의 성능에 따라 좌지우지되기때문에 중요한 이슈다.

caching, prefetching 개념.

48)
13~15장
마지막으로 file system.

2장 start

3)
오퍼레이팅이 제공하는 서비스

사용자관점)
- 유저 인터페이스, 크게 3가지 - CLI(Command-line interface) - Batch interface - GUI 
- 프로그램 실행(os의 제일 중요한 목적)
- io 연산

4)
- 파일 시스템 관리
- 프로세스간의 커뮤니케이션
- 에러 디텍션

5)
시스템관점, 효율성 관점)
- 리소스(cpu, 메모리, 스토리지, io디바이스) 할당 multitasking(여러 프로세스들이 자원을 할당받으려 싸우는데 os가 중재해준다)
- accounting
- protection
- security

6)
user interface,
cli 와 gui

batch interface란?
일련의 명령어들을 연속적으로 수행하도록 파일이 기억하는 것.
cli를 advanced 시킨것
가장 유명한 batch interface : Makefile(리눅스에서의 툴)
	컴파일들할 파일들이 많을 때 매우 유용한 툴이다

7)
CLI의 핵심은 shell
shell : 1)명령어를 받아서 해석하고 2)수행하는 프로그램
해석하고 수행하는 2가지 방법
- shell 자체내에 모든 명령어들을 수행하는 코드를 넣은 -> 크기가 매우 커진다..
- 실제 그 실행되는 파일들은 보통 bin 디렉토리내에 있는데 shell에서 그안의 rm이란 파일을 찾아서 수행하는 것

문제) shell 자체에 프로그램이 들어있다? -> x
그냥 디텍토리 내에서 rm 파일을 찾아서 수행하면 된다.

8)
GUI
윈도우는 당연히 쓰고있고,
최근에는 리눅스나 유닉스도 편한 gui를 갖기 시작했다.

리눅스의 오픈소스라는 장점이 점점 발전시키는 계기가 되었다.

9)
accounting
작업관리자 페이지를 기억하자.
프로그램 하드웨어의 통계자료들을 확인할 수 있다.

10)
⭐️시스템콜, os에서 매우 중요한 메커니즘중 하나

커널모드로 진입할 수 있는 2가지 방법
- hardware interrupt 비동기적으로 진입. io에서 interrupt가 오면 무조건적으로 수행. interrupt는 커널 내에 있는 프로그램이기 때문에 커널모드로 들어가는것. 유저모드에는 없다.
- Trap - exception : 여러 오류나 예외가 발견했을 때 - ⭐️System call

11)
시스템 콜이 뭐냐?
메카니즘이다, 어떤?
애플리케이션 프로그램이 os로부터 서비스를 요청할 수 있는 방법.
-> os로부터 서비스를 받으려면 오직 이 방법뿐

-> API를 통해서 시스템콜을 호출.

시스템콜을 호출하면 -> 커널모드로 진입( 시스템콜은 커널안에 있는 코드니까)
-> 끝나면 다시 유저모드로

12)
os를 설계할 때 있어서 구분해야할 개념.
1. Policy 무엇을 할 것이냐? -> 목적
2. Mechanism 어떻게 할 것이냐? -> 방법

시스템콜은 Mechanism
목적은? os로부터 서비스를 받기위한 목적(policy)를 달성하기 위한 방법

timer도

13)
시스템콜은 무수히 많이 일어난다.

파일을 카피하는 명령을 쳤다고 예시를 들어보자.
이와 같은 단순한 연산도 무수히 많은 시스템 콜이 일어난다.
왜 이렇게 많이 발생하냐?
os로부터 서비스를 받을 수 있는 유일한 메커니즘 이기 때문

14)
어떻게 호출하느냐?
by API -> indirectly(간접적으로) 시스템콜을 호출시킨다.

indirectly ?  응용프로그램가 직접 x -> 라이브로리함수로 간접적으로호출하는 메커니즘

POSIX : 표준이라고 생각하면 된다.
유닉스계열의 여러 os가 있는데, os가 달라져도 posix를 따르면 프로그램을 동일하게 쓸 수 있다.

문제)
malloc()은 시스템콜인가?
-> 아니다, malloc()안의 sbrk()가 시스템콜이다.

이와같이 간접적인 메커니즘 사용

15)
그럼 왜 간접적으로 호출하게 했을까?

- Portability os가 달라져도 동일한 api를 써서 호출하기 때문에.. 좋다
- 프로그래밍이 쉬워진다.

16)
시스템콜 인터페이스
= 테이블 형태로 시스템콜을 관리해준다.
이유) 관리용이, 효과적

시스템콜 테이블
왼쪽엔 시스템콜 넘버들
오른쪽엔 함수들

응용프로그램에서 시스템콜을 호출한다?
-> 시스템콜 넘버만 확보하게되면 해당 함수들을 찾을 수 있다

17)
예시
라이브러리를 통해 간접적으로 호출
-> 라이브러리 함수 안에 시스템콜이 들어있고
-> 시스템콜 넘버만 알고있으면, 해당 함수 호출

18)
들어가는 인자는 시스템콜넘버.

19,20) 나중에설명

21)
fork() : 라이브러리함수

fork()안의.. 2가 시스템콜넘버

시스템콜은 interrupt로 관리해준다. 이유) trap의 일종이기 때문
-> interrupt handler를 통해 관리
IDT = interrupt description table = interrupt vector

divide_error() (0으로 나누는 연산) -> exeception -> interrupt로 처리 -> interrupt vector로 관리

