# os 3주차-1

지난시간.
리눅스 시스템콜 설명하다 설명 마쳤다.

1. ⭐️ 이그림 다시설명해달라고 요청, 천천히

이 그림이 중요

먼저 user task에서 fork()를 호출
fork()는 뭐냐 -> 라이브러리 함수임. (시스템콜 자체가 아님)

fork()를 호출한 라이브러리 : libc.a

move 2, %eax  : 2가 시스템콜 넘버
int $0x80 : interrupt라는 뜻

19)
시스템콜에서 인자를 넘기는 방법

시스템콜은 커널에 있다.
호출하는 것 user program에서 호출한다.
따라서 인자를 넘길 방법이 효과적인게 없다.
커널과 user program은 엄격하게 분리되어있기 때문에,
인자를 커널로 넘기는 방법도 다른 방법이 필요하다
	-> register을 통해 넘긴다!

두번째 방법
여러개의 인자를 넘기고싶은데 register의 개수는 한정되어있다.
메모리 특정부분을 block으로 지정하고,
그 주소값을 레지스터에 저장하고 넘김

20)
block 방법 설명

리눅스에서는 인자의 개수가 6개보다 같거나 작을때는 레지스터 사용.
6개이상일 때는 2번째방법인 주소값을 넘겨준다.

22)
시스템프로그램과 애플리케이션프로그램의 차이?
시스템프로그램은 시스템을 관리하기위한 프로그램
ex) 작업관리자
프로그램 개발이나 수행을 효과적으로 주기위한 환경

시스템프로그램은 시스템콜이 많이 호출된다.

23)
시스템콜은 매우 많다.
- 프로세스 제어 프로세스를 끝내고, 중간에 끝내고, 프로세스를 만들고 등
- 파일 관리 파일 생성, 오픈, 리드, 라이트
- 디바이스 관리 파일관리법과 유사(중요)
- information maintenance 시간과 날짜를 얻는게 왜 시스템콜? real time clock이라는 하드웨어가 있는데, 거기에 현재시간이 들어가있어서 -> os에게 물어봐야함, os만이 하드웨어에 접근할 수 있기때문
- 커뮤니케이션

24)
os를 설계하고 구현하는 방식
쉬운일은 아님. 

os개발시 목표?
사용자입장 - …
시스템입장 - …

25)
마이크로 커널기반의 os만 간단하게 언급하겠다.
우리가 제일많이 보는건 monolithic kernel, 마이크로커널의 반대 개념. 리눅스와 윈도우즈 등 대부분 모놀리틱 커널임 : 모든 os의 기능을 커널내에 넣음

마이크로 커널은 독특한, 흔히 접하지않은 커널.
-> 예전에 피쳐폰
os의 많은 기능들을 커널모드가아닌 user mode(user space)로 올렸다. 예를들어 device driver도 user space에 있음
-> 커널이 단순화됨.
커널에는 key element만 있음(프로세스 매니지먼트) -> 나머지 기능은 다 user space로 감.

-> 마이크로 커널에서는 policy가 바뀌어도 수정하기 쉽다. 효과적으로 adaptation 할 수 있다.

26)
os의 다양한 구조
5가지 구조.

27)
심플스트럭쳐 -> 듣고 잊어라. 예전 os만 있고 지금은 없음.
no dual-mode(privileged instruction), no h/w protection
큰 문제점 : Protection

29)
layered approach. 현재 대부분의 os가 씀
os이 계층화 되어있다.
가장 낮은 레이어 : h/w
가장 높은 래이어 : 유저인터페이스

정의중요 : 각 레이어는 low레이어에서 제공되는 오퍼레이션에 의해서 구현이 된다.
응용프로그램은 -> 커널 (by 시스템콜)
커널 -> 하드웨어 (by h/w 인터페이스)

30)
핵심 -> 각 레이어는 low레이어에서 제공되는 오퍼레이션에 의해서 구현이 된다.
역방향은 지원이 x

우리가 프로그램을 작성할 때(유저) 커널, 하드웨어단을 고려하는가? -> x
each layer can be debugged without any concern for the rest oft the system
-> 아래 레이어에 대해서 고민할필요 x

31)
최상위 : 사용자
그 위 : 애플리케이션
그 위 :커널
제일 아래 : 하드웨어

32)
마이크로커널
많은 기능들을 user space로 올림.
커널의 간결화

장점
extension이 쉽다
porting이 쉽다 (이유 : 커널이 마이크로화 되어있기 때문)
안정적임 (코드가 적기때문)

단점
message passing이 많이 일어나야함 -> 오버헤드
이유? 많은 기능들이 User space로 올라왔기때문에 커뮤니케이션이 많이 일어날 수 밖에 없다.

마이크로커널에는 대표적으로 
Mach OS : CMU, research
QnX (real-time os : RTOS)
REX(Feature phon) : Real-time Executive
가 있다

33)
모듈기법.
현재의 리눅스도 모듈기법이 포함되어있다.
리눅스는 기본적으로 layered approch에 모듈기능을 추가했다
linux = layered approach + Module

레이어드 어프로치는 계층별로 구분했다면,
모듈이 뭐냐 그럼
모듈의 핵심
1. 기능별로 구분. 어떤기능을 하느냐.
2. 각각의 모듈이 필요에 따라서 별도로 로딩/언로딩 이 가능하다. 모듈의 제일 중요한 특징 ⭐️ -> 즉 커널이 동작할때 특정기능을 추가할 수 있다는 뜻

34)
기능별로 모듈을 별도로 두었다.
각각의 기능들을 필요없을 땐 제거, 필요할 때는 추가하는 것이 가능하다.
별도로 로딩, 언로딩이 가능한 시스템.

35)
각각 기능을 별도로 로딩/언로딩하는게 왜 중요?

키워드는 Device driver.
Device driver를 실제 적용하고 구현하는데 효과적일 수 밖에 없다.

모든 Device(하드웨어)는 구동하는 소프트웨어가 필요하다. -> 이를 Device Driver 라고 한다.
그럼 디바이스 드라이버는 어디있나?(모놀리틱 커널에선) -> 커널에 있다.
문제는 커널이 현재 수행중인데, 수행중인 프로그램에 중간에 기능을 추가한다? -> 일반적으로는 불가능함
or가 동작중인데, 새로운 디바이스를 넣으려면 -> 커널을 리컴파일해야한다?
하지만 이러한 끔찍한 상황은 없다! -> 모듈 이라는 기능 덕분에.

정리,
os가 동작중임에도 불구하고 새로운 기능을 os에 추가할 수 있다.
특히 device driver에 유용하다.

커맨드 하나로 모듈을 다이나믹하게 붙이고, 뗄 수 있다.
매우 심플하게 해결.

36)
마지막 아키텍처, 
버츄얼 머신

버츄얼 머신의 핵심 
: os간 하드웨어를 공유하되, 여러개의 os을 concurrently 돌리는 것.
-> 한마디로 데스크탑위에서 리눅스, 윈도우즈, 솔라리즈 같은 다양한 os가 동시에 실행될 수 있도록 지원해주는 것.

어떻게 하느냐가 이슈
각각의 os는 자기만의 컴퓨터를 가지고 있는 듯이 illusion(환상)을 창출하는 것이 핵심.
illusion?
실제로는 하드웨어(피지컬 머신)는 1개인데, 버츄얼머신은 여러개.

개발자 입장에서는 concurrent test할 때 매우 유용하겠다.
하지만 os개발자 입장에서는 구현이 쉽지가 않다.

37)
왼쪽 : 여러개의 피지컬머신
오른쪽 : 피지컬머신 1대.

버추얼머신의 핵심은, 중간에 Virtualization layer가 반드시 존재해야함.

38)
각각의 버추얼머신 입장에서 보면
버추얼 user space와 버추얼 kernel 이 있는데

실제 Virtualization layer 관점에서는
각각의 버추얼머신들은 유저모드(유저 프로그램)에 속한다.
그리고 Virtualization layer을 포함해서가 커널모드.

39)
Vmware
핵심
일반 애플리케이션은 host operating system 위에서 동작
버츄얼 위에서 돌아가는건 guest operating system 위에서 동작 

40)
시스템 부팅
부팅 : 전원을 키고 나서 os에게 제어권을 넘길때 까지의 과정
powering on (boot loader) -> os
bootloader의 핵심 : os를 로드하고, os에게 제어권을 넘김

bootloader는 전원이 켜지자마자 수행되어야함.
ROM에 있다. 보통 disk의 맨 첫번째 블락

os를 설치할 때 있어서 핵심
어떤 하드웨어가 쓰이느냐
각 하드웨어에 맞도록 구현되어야아하기 때문
-> System generation 과정 : Os를 제대로 설치하기위해서 필요
- os가 하드웨어디바이스에게 자동으로 체크 -> 이 프로그램이 SYSGEN program 하드웨어 인포메이션을 획득할 수 있는 프로그램.

