# OS 8주차-2

실제로 뮤텍스와 세마포어를 통해 스레드프로그래밍을 할차례다.
posix의 synchronization

1)
포식스의 뮤텍스는
다음 네모박스와 같은 프로토타입을 갖는다.

pthread.h를 인클루드.
phtread_mutex_t 타입의 mutex 변수 선언

1. 뮤텍스를 초기화.
인자로 뮤텍스의 주소값과 attribute 변수를 넣어준다.
그러나 보통 attribute는 null 값을 넣어준다. -> 디폴트 attribute를 하겠다는것

2. 크리티컬 섹션 앞뒤로 뮤텍스 락, 뮤텍스 언락 함수 넣어줌
인자로 뮤텍스 주소값
![OS 8주차-2](images/OS%208주차-2.png)

2)
다시한 번 정리

뮤텍스 언제쓰나? -> 크리티컬 생성

해야할일
1. 뮤텍스 생성 (pthread mutex init)
2,3. lock, unlock함수를 크리티컬섹션에 pair로 호출
4. 뮤텍스 destroy

3)
각 함수의 프로퍼티를 보자

pthread_mutex_init

4)
pthread_mutex_lock

이 함수에서 뮤텍스 값이 0보다 같거나 작으면, 여기서 프로그램이 블락되겠다.
뮤텍스값이 양수가 될때까지.
양수가 되면 크리티컬 섹션에 진입

5)
pthread_mutex_unlock

뮤텍스 값을 1 증가시킴

6)
phtrad_mutex_destroy

뮤텍스가 필요없을 때 호출하여 폐기함

7)
이젠 포식스 세마포어.

세마포어의 프토로타입
세마포어.h include
세마포어 변수 선언
세마포어 변수 초기화
	첫번 째 인자 : 세마포어 변수의 주소
	두번 째 인자 : 여러 프로세스간에 해당 세마포어를 공유할것인가
				값이 0이면 한개의 process에서만 사용한다는 뜻
				보통 세마포어변수는 한개의 프로세스내에 여러개의 스레드들 간의
				공유변수를 쓸 때 사용한다.
	세번 째 인자 : 세마포어의 초기값
				1이면 바이너리 세마포어.
				크리티컬 섹션에선 바이너리 세마포어를 써야한다.

크리티컬 섹션에서는
![OS 8주차-2-1](images/OS%208주차-2-1.png)

다음과 같은 함수 호출

8)
따라서,
포식스에서 세마포어를 활용하려면

1. 세마포어를 초기화. (sem_init). 3개의 인자
2. sem_wait -> wait 역할
3. sem_post -> signal 역할

9)
6장, 7장 키워드

————————————————————————

8장. 데드락

3)
데드락 problem

데드락은 프로세스가 1개일때 발생하지않음.
여러개의 프로세스가 연관되었을 때 발생될 수 있음.
연관되었다고 항상 발생되는건아니고, resource라는 매개체가 존재해야함.

데드락, 핵심은 “ indefinite blocking “
무한정 블락 되는것.

블락될경우? 리소스를 기다릴 때. 어떤 리소스? 다른 프로세스가 소유한 리소스.
다른 프로세스가 소유중인 리소스를 접근할때 무한정 블락되는 현상이 발생될 수 있다.
-> 이게 데드락이 발생하는 전형적인 case

예시)
p1, p2가 각각 디스크 드라이버 하나 소유.
상대방이 소유한 다른 디스크를 필요로 할 때 발생될 수 있다.

또 다른예시)
두개의 세마포어 A, B가 1로 초기화 된 상태 -> 이 세마포어가 뮤텍스로 사용된 다는 것을 의미. 즉 바이너리 세마포어. (바이너리 세마포어 = 뮤텍스)

P0의 wait(A)가 수행되면 -> A = 0
공교롭게 컨택스트 스위치
p1의 wait(B) -> B = 0
=> 두 프로세스 다 무한정 블락. 데드락.

4)
또하나의 예.

도로의 섹션들을 리소스라고 생각하고, 자동차를 프로세스라고 생각하자.

5)
앞선 예시를 어떻게 해결할까.

데드락 복구 방식. Dead lock recovery
1. 자동차를 강에 던진다 -> 프로세스를 죽인다 데드락과 연관된 프로세스 중 하나를 Kill 한다
2. 자동차를 후진한다 -> 프로그램을 rollback한다. 이전수행상태로 되돌리는 방식.. 복잡하겠다.

6)
또다른 예

다음과 같은 상황에서 버스가 진입하면 무조건 데드락 발생할것임
=> Deadlock avoidance
프로그램을 실행시 데드락 발생이 예상되면,
프로그램 수행을 잠시 멈추는것. 데드락이 발생안될 때 까지. safe state에서.
safe state:절대 데드락이 발생하지않는 state
![OS 8주차-2-2](images/OS%208주차-2-2.png)

7)
또다른 예

데드락이 이미 발생되어버림,
이와 같이 데드락이 발생한 상황을 검출하는 것을 -> Deadlock detection

이 데드락 디텍션 조차 쉽지않은, 어려운일이다.
실제로 프로세스가 매우 많고 복잡하니까.

효과적인 데드락 디텍션 알고리즘이 필요하다.

8)

배울 컨텐츠 중에 deadlock prevention.
데드락을 예방하는 좀 강력한 방법.
데드락이 발생될 필요조건 중 하나를 없애버림.

9)
데드락을 모델링을 먼저 할 수 있어야한다.
모델링 기법

데드락과 연관된 2가지 object들.
resource, process
이 두 가지를 어떻게 모델링 하는지 살펴보자.

리소스는 보통 Ri 형태로 모델링한다.
![OS 8주차-2-3](images/OS%208주차-2-3.png)

리소스는 피지컬 리소스, 로지컬 리소스
피지컬 리소스 : 하드웨어. cpu, 메모리, io 디바이스 등
로지컬 리소스 : 프로그래밍 환경에서 쓰이는 object들. 대표적으로 세마포어, files
보편적으로 데드락을 설명할 때 세마포어로 설명한다.

여튼 어떤 리소스던 Ri 로 표현한다.

추가적으로 instance라는 개념이 도입된다.
instance : 특정 리소스 타입의 개수
만약 2개의 CPU가 있다고 가정하면,
-> 이 때 CPU 타입의 리소스는 2개의 인스턴스를 가진다. 라고 말한다.

프로세스가 리소스에 행하는 연산이 있다.
Request : 프로세스가 특정 리소스를 요청하는 것. 	전형적으로 세마포어의 wait함수라고 사용하면 된다.
Use  : 사용한다. 즉 wait 함수에서 통과해서 해당 리소스를 사용할 수 있다는 것을 의미
Release : 리소스를 다 사용함. 즉 세마포어의 signal함수로 표현할 수 있다.

request와 release는 세마포어 형태로 표현이 가능하다.
추가적으로 시스템콜이 필요할 수 있다.

Hold & request
특정 리소스를 홀드한다 = 사용한다. use를 의미
그러는 동시에 다른 리소스를 request
이 홀드앤리퀘스트가 데드락의 필요조건 중 하나에 해당

10)
데드락의 “필요조건”

필요조건이란,
데드락이 발생되었다. 봤더니 -> 아래 4가지 조건이 다 만족되는걸 확인할 수 있다.
그러나 4가지 조건이 만족했다 -> 이렇다고해도 반드시 데드락이 발생하는건 아니다.

- Mutual exclusion
오직 1개의 프로세스만이 크리티컬섹션에 있는다.
리소스에 적용하면, 오직 1개의 프로세스만이 특정시점에 리소스를 사용할 수 있다.

- Hold and wait
어느 리소스를 쓰고 있으면서, 다른 리소스를 리퀘스트 했는데 다른 프로세스가 이미 사용중인경우 wait 상태가 된다.

- No preemption
(?)

먼저 수행되었던 프로세스가 리소스를 자발적으로 놓아야지만 다른 프로세스가 리소스를 사용할 수 있다.

- Circular wait
예를 들어서 프로세스 p1이 p2가 소유한 리소스를 기다린다.
p2는 p3가 소유한….
![OS 8주차-2-4](images/OS%208주차-2-4.png)

이렇게 기다리는 관계가 싸이클을 이룰때 circular wait 속성을 갖고있다고 말한다.

11)
circular wait을 브릿지 크로싱 예시로 살펴보자

12)
Resource Allocation Graph

리소스가 프로세스에 어떻게 할당되는지를 그래프형태로 그림을 그린것.

이걸 왜 그릴 수 있어야하나.
-> Resource Allocation Graph를 통해서 데드락을 효과적으로 detection 할 수 있기 때문.

그래프는 2개의 타입으로 분류. 하나는 프로세스, 하나는 리소스

프로세스는 일반적으로 동그라미, 리소스는 네모 형태로 표현
![OS 8주차-2-5](images/OS%208주차-2-5.png)

여기에 화살표를 그리는게 핵심.

request edge : 프로세스가 리소스를 사용하겠다고 요청하는 것 ( P -> R)
assignment edge : 리퀘스트를 했는데, 리퀘스트가 accept가 된것 ( R -> P)

13)
사각형 안의 또다른 사각형.
내부의 사각형은 인스턴스를 의미

CPU

