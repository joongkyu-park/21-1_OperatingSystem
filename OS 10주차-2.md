# OS 10주차-2

37)
Deadlock Detection

싱글인스턴스
-> RAG를 그려라. -> 싸이클이 존재하는지 여부 확인

멀티플 인스턴스
-> 뱅커스 알고리즘을 변형한 기법을 쓰자
뱅커스 알고리즘은 avoidance 알고리즘 이었다. -> 한마디로 미래를 보는것. 미래에 데드락이 발생할것 같으면 회피.
그러나 detection은 현재를 보는 것.
따라서 need <= available이 아니라, 현재니까
request <= available를 찾는다.

먼저 싱글인스턴스
wait for 그래프란
![OS 10주차-2](images/OS%2010주차-2.png)

RAG그래프에서 리소스를 지워서 기다리는 관계를 간략화 시킨것

38)
멀티플 인스턴스.
뱅커커스 알고리즘과 유사한데, 미래를 현재로.

39)
오타.
available이아니라 allocation
![OS 10주차-2-1](images/OS%2010주차-2-1.png)

40)
마지막 토픽. recovery.
데드락 발생했으면 복구하자.

방법 2가지

1. 프로세스(들)을 kill 한다. -> os가 아니라 operator(사용자, 관리자)가 한다.
2. rollback. 데드락이 detection이 되었다면 이전의 safe한 state로 되돌아가서 재수행한다.
-> 그러나 일반적으로 가능하지않나..
왜냐하면 그 때의 register나 stack 등의 context에 대한 정보, 그떄의 문맥을 가지고 있어야한다.
따라서 특정 라인의 context 정보를 저장해야한다 => checkpoint.
따라서 rollback을 보통 checkpoint & rollback이라고 한다.
체크포인트까지가 롤백이 가능한 범위

![OS 10주차-2-2](images/OS%2010주차-2-2.png)

41)
프로세스 종료
데드락에 연관된 모든 프로세스를 킬하거나

스텝바이 스텝으로 킬할경우는, 관련된 프로세스를 하나하나 종료시킨다.
그때 어떤 프로세스를 먼저 종료시켜야하는지는 아래 3가지에 따라서.

42)
롤백
예시로 보자

43)
![OS 10주차-2-3](images/OS%2010주차-2-3.png)

다음과 같을때, B로만 되돌아 갈 수 있다. 왜냐하면 그 라인의 state information이 있기 때문에.

9장.
메모리 매니지먼트

3)
오버뷰
이 단원에서 가장 중요한 개념은 virtual memory

문제.
![OS 10주차-2-4](images/OS%2010주차-2-4.png)

이렇게 출력하면, a의 버츄얼 주소가 출력되나, 실제 피지컬 주소가 출력되나?
=> 버츄얼 어드레스가 출력된다
프로그램상에서의 주소는 버츄얼이다.
또 CPU가 바라보는 주소도 버츄얼이다.

실제 메모리에 저장된 주소는 physical address이다.

따라서 virtual address -> physical address로 변환 시켜주는
“address translation” 이 필수이다. => 이것이 이번단원의 핵심

문제2.
왜 버츄얼 어드레스 라고하는 복잡한 개념을 썼을까?.. 그냥 피지컬 쓰지..
->  보다 넓은 공간을 쓰기 위해서이다.
![OS 10주차-2-5](images/OS%2010주차-2-5.png)

![OS 10주차-2-6](images/OS%2010주차-2-6.png)

따라서 M<N 이다.

그러면 피지컬메모리공간을 초과할 수도 있다,.
![OS 10주차-2-7](images/OS%2010주차-2-7.png)

그럼 이때 어떻게 해야하나?
=> “swapping out/int”
누구를 쫓아낼것이냐..

4)
효과적으로 address translation 방법은 무엇일까.
-> Table을 두어서 관리하는 것이다. => Paging table
![OS 10주차-2-8](images/OS%2010주차-2-8.png)

5)
A 프로세스를 요청했는데 메인 메모리에 올려야한다.
그래서 disk에서 A를 찾아서 메인메모리에 올려야하는데, 메모리가 꽉찼다.
따라서 어떤 프로세스를 swapping out 시켜야하는데, 어떤 프로세스를 쫓아낼것인가. 이것이 이슈.
 -> LRU 기법 사용. Least Recently Used. 가장 최근에 사용안된 페이지를 쫓아낸다.

6)
9장과 10장에서 배울것.

7)
연관된 몇가지 기본 개념.

Address translation은 굉장히 빠르게 일어나야한다.
Address translation을 도와주는 하드웨어
-> MMU (memory management unit)
2가지가 있다. register, TLB(Translation Lookaside Buffer)
register는 A.T와 memory protection을 돕고
TLB는 table을 저장한다.

Register
contiguous allocation
연속적으로 할당된다.
프로세스는 연속적으로 메모리에 저장된다.
-> 시작주소를 알아야한다.
register에 시작주소를 저장해놓는다. -> 메모리를 바로 접근하는 거보다 훨씬 빠르다.
프로세스의 크기만큼 저장된다.
-> 크기를 초과하는, 즉 limit을 초과하는 범위를 접근하면 보호해준다.

따라서 register는 AT와 MP를 돕는다

8)
base와 limit을 레지스터에 저장하므로써
프로세스의 range를 효과적으로 알 수 있다.

9)
두번 째 개념.
address binding
주소가 결정되는 것.

결국 메모리에 접근하려면 절대 주소(Absolute Address)를 확보해야한다.

프로그램의 lifecycle
1. Compile time
2. 컴파일한 오프젝트를 linking time
3. 링킹한 바이너리를 최종으로 execution time 

프로그램의 Absolute Address는 언제 결정되나?
즉 피지컬 메모리에 있는 주소로 언제 변환되나?
3번이 답이다.

10)
위 내용의 플로우
![OS 10주차-2-9](images/OS%2010주차-2-9.png)

11)
컴파일 타임에 어드레스가 결정된다면?

절대주소(피지컬 메모리 주소)는 계속 바뀔 수 있다.
왜냐하면 계속 스왑인 스왑아웃 되기 때문에 피지컬 메모리는 계속 바뀔 수 있다.

따라서 컴파일타임, 로드타임에는 절대주소가 결정 될 수 없다.
왜냐하면 주소가 바뀔때마다 리컴파일, 리로드 되는건 말도 안되니까.

따라서 execution time에 절대주소가 결정된다.
따라서 프로그램을 재실행할 때마다 절대주소가 바뀔 수 있게된다.
그렇기 때문에 빠르게 address translation하려면 MMU와 테이블의 도움이 필요하다.

12)
버츄얼 어드레스 = 로지컬 어드레스

13)
같은 버츄얼어드레스지만 프로그램 실행때마다 피지컬주소는 계속바뀔 수 있고.
이는 execution time 때 binding 된다.

14)
MMU
레지스터와 TLB
메모리 접근시간 보다 훨씬 빠르기 때문에,
메모리에 관련한 핵심정보를 레지스터에 저장해놓으면 빠르다.

15)
![OS 10주차-2-10](images/OS%2010주차-2-10.png)

메모리 접근시 mmu의 도움을 받는다.

16)
다음 개념.
프로세스 어드레스 스페이스.
프로그램 상의 주소 공간. -> 버츄얼 어드레스

이해를 돕기위한 예시.

리눅스에서는 각각의 프로세스마다 자기만의 버츄얼 어드레스 스페이스로 약 3GB씩 준다.
stack영역은 거의 3GB에 가까운 쪽에서 발견된다.

17,18)
실제 버츄얼어드레스 스페이스 확인
a와 b는 서로 다른 프로그램
![OS 10주차-2-11](images/OS%2010주차-2-11.png)

코드영역의 메모리 주소가 같은걸 볼 수 있다.
근데 이것은 버츄얼 공간이기 때문에, 실제 메모리 공간은 다르다.

따라서 동일한 text영역을 가져도 문제되지 않는다.

이것을 그림으로 보면 
![OS 10주차-2-12](images/OS%2010주차-2-12.png)

이와 같은 시나리오에서 mapping table은 어디에 있나.
다른말로 page table이라고 불리는데, 이 테이블은 프로세스마다 있어야한다.
왜냐하면 위의 시나리오에서 프로세스마다 테이블을 가지고 있어야하니까.

따라서 PCB안에 페이지테이블이 데이터스트럭쳐로 있다.

페이지테이블은 프로세스마다 있다.

