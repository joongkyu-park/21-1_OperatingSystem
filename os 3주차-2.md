# os 3주차-2

지난시간에 2장 마지막 부분하다가 마쳤다.

42)
부팅과정.

부팅과정은 시스템을 키고나서, os에게 제어권을 넘길때 까지.
핵심: 부트스트랩 로더. 일명 부트로더
부트로더의 역할?
1. 필요한 하드웨어 초기화
2. 오퍼레이팅 시스템을 로딩하고, 오퍼레팅시스템의 메인함수의 첫번째 라인을 실행한다. -> 오퍼레이팅 시스템에게 제어권을 넘긴다.

코드가 간단하면 그냥 ROM에 저장되어서 부팅되자마자 부트로더가 맨먼저 수행.  -> 싱글스텝
근데 일반적으로 ROM의 수행코더는 RAM보다 느려서, 부트코드를 RAM으로 올려놓고, RAM의 제어권을 넘길 수 있다 ->  투스텝

43)
싱글스텝

두가지 이슈가 있을 수 있다.
1. ROM이 RAM보다 느리다. (스피드 측면) 부팅 과정도 좀 빠르게 하자.. -> 부팅 과정을 담고 있는 코드를 RAM으로 올리자
2. ROM의 크기가 작을 수 있다 (사이즈 측면)

44)
투스텝
부트스트랩로더는 당연히 ROM에 있다
근데 부팅과정을 담고 있는 코드(부트블락)가 disk에에 있고,
rom이 disk에서 ram으로 올리는 역할.
일반적으로 disk의 첫번째 블락은 부트블럭이다

부트블럭은 Os에게 제어권을 넘기는 역할

2장을 마친다.

3장. 프로세스

2)
아웃라인

3)
프로세스 개념.
프로세스는 뭐냐, 프로그램이다, in excution 즉 수행중인.

용어로 job, task, process라는 말을 혼합해서 쓴다.
이유. os마다 쓰는 용어가 다르기 떄문

4)
프로세스, 현재 수행중인 프로그램
프로그램과 다르다.
뭐가 다르냐.
1. 프로그램이 수행되려면 메모리로 로딩이 되어야한다. process address space -> 버츄얼 어드레스임. = 프로세스가 차지하고 있는 메모리공간  text : code data : 함수 밖에있는 전역변수들 heap : 동적으로 할당된 메모리 (malloc 함수->동적메모리할당, free하면 해제) stack : 로컬변수, 함수인자들 (함수를 호출하면 호출할수록 증가된다.)  => cpu가 바라보는 주소공간 -> 버추얼 어드레스이다!.  PCB: 해당 프로세스의 모든 정보를 담고있는 데이터스트럭쳐이다.  Program counter, Processro register 값을 갖는다. (Program counter : 다음에 수행될 명령어를 가지고 있는 레지스터)

5)
process address space를 이해하기 쉽게 코드로 작성했다.

6)
프로그램은 disk에 있는데,
프로세스가 되려면 메모리에 올라야되고 pcb, 스택등 추가적인게 필요

7)
프로세스는 액티브하다. (프로그램은 패시브적)
1. 함수를 콜하면 콜할때마다 스택사이즈가 증가된다. 동적메모리를 해제하면 힙사이즈 줄어든다 -> 액티브하다
2. text에서 수행되는 코드가 계속 달라지니까 레지스터도 달라진다

8)
프로세스는 state를 전환한다.
5가지 state
- new : 프로세스가 생성되면 젤먼저하는거
- running : 태스크 러닝상태
- waiting : IO디아비스요청 또는 sleep
- ready : 레디(대기)상태 존재이유? 수행할 수 있는데 못하는 상황 -> cpu가 다른 프로세스를 수행중인 상황인것임.
- terminated

스케줄러
현재 ready상태에 있는 태스크가 여러개 있을 수 있는데, 그 중 하나를 선택하는 것.
선택된것은 러닝이다.
다른 것들은 ready 상태.

waiting과 ready는 다르다
io를 요청하면 waiting상태가된다. 뭔가 이벤트를 기다릴때.

Q. 웨이팅상태에서 cpu를 할당받아서 수행할수 있다 없다. -> X

9)
state 그림

scheduler와 dispatcher
dispatcher : 선택된것을 cpu에 할당하는 것

왜 interrupt가 발생하면 러닝->레디 가 될까? io도 안했는데.
interrupt가 발생하면 ISR이 무조건적으로 호출되는데
일반적으로 ISR이 끝날때 interrupt에서 나가게되는데, 그 때 보통 스케줄링 디시젼을 내려준다 -> 인터룹트 호출 될 때 러닝에서 레디상태로 우선순위가 낮은 태스크는 전환될 수 있다.

10)
리눅스같은 경우의 분류. 조금더 세분화한 경향
다른것들은 세분화된 경향이 있는데
특이한것은 task_running가 러닝,레디 상태를 모두포함

-> os마다 다르다~

11)
PCB
각각 프로세스에 연관된 모든 information

PCB에서 program counter나 cpu registers가 들어있다.
그거 말고도 등등등

12)
리눅스에서 관리하는 법.
-> 프로세스의 모든 정보들이 다 들어있다.

많은 os에서는 효과적으로 관리하기위해서 구조체형식을 사용한다.

13)
핵심은 ( … )임. 훨씬 많은 정보들이 PCB에 들어있다.

14)
레지스터값이 어떻게 저장되는지 집중적으로 보자

프로세스간 컨택스트 스위치 : a 수행하다가 b 수행하는것, 언젠간 다시 a로 돌아와야하는데, 그때의 문맥들이 PCB에 저장된다. a를 다시 재수행해야하기때문에.ㅌ

컨택스트 스위치 : cpu가 다른 프로세스를 dispatch하려고함 \

15)
현재 P0가 수행중이다가 P1에 컨텍스트 스위치가 되었다.
-> PCB0에 현재수행중인 문맥들 저장

… 나중에 다시 되돌아와서 P0가 수행될때 PCB0에 문맥이 저장되었었기 때문에 재수행할 수 있다.

16)
프로세스 스케줄링 (스케줄링은 5장에서 자세히 배울것이다.)
os에서 스케줄링 굉장히 중요하다. -> 멀티태스킹 때문

여러 태스크들을 Hold할수 있는 queue가 있어야한다.
그중 하나를 선택하는게 스케줄러의 일.

job 큐 : 모든 태스크
ready 큐 : 레디상태인 태스크 -> job큐가 super set인 격
디바이스 큐

17)

18)
스케줄링할 때 어떤관점에서 하느냐 -> 스케줄러를 2개로 구분
구분하는 이유? 스케줄링을 잘하기 위해서

- io 바운드 프로세스 io 요청, 연산을 많이 하는 프로세스 -> 워드 프로세스 같은것!
- cpu 바운드 프로세스 cpu 연산량이 많은것 -> 소프트웨어 코덱(영상같은거 압축하는거)

19)
2개 어떻게 분류하느냐
cpu연산하다가, Io연산하다가… 반복 (cpu연산하는걸 cpu burst, io연산하는걸 .. 라고함)

왼쪽은 cpu-intensive
오른쪽은 io-intensive 라고한다.

cpu 스케줄러는 누구에게 우선순위를 높게줄까? -> io-intensive 이다.

20)
왜?
보다 많은 프로세스의 기다리는 시간을 줄이기 위함. 전체적인 웨이팅 시간을 줄이기 위해.

21)
또 하나의 분류.
롱텀 스케줄러 - 자주불리지않음
쇼트텀 스케줄러 - 자주불림
미디어텀 - 텀이 중간

22)
롱텀스케줄러.
 현재 유닉스, 윈도우즈에는 롱텀스케줄러 없다 ^^.. -> 모든 프로세스를 메모리에 놓는다.
따라서 실제로 의미없다 

프로세스를 실행했을 때 수행할것인가, 말것인가를 결정

23)
매우 텀이 짧은거
매우 자주수행(밀리세컨드 단위) 리눅스같은경우는 10ms마다한번씩 스케줄러 호출. 10ms마다 한번씩 컨텍스트 스위치가 될 수 있다
쇼트텀 스케줄러는 레디 상태에 있는 거중에 하나를 선택하는거.
일반적으로 말하는 스케줄러.

24)
미디엄 텀 스케줄러.
모든 태스크를 메모리로 로딩할 수 있나.. 불가하다
-> 누군가 swap out 해야한다.

미디엄 텀 스케줄러는 swap out될 프로세스를 결정한다.

25)
프로세스가 수행이 전환이된다. -> 컨택스트 스위치
핵심 : 기존의 수행되있던 문맥을 그 태스크의 PCB에 저장한다.
새로운 태스크의 문맥도 역시 새로운 태스크의 PCB에서 가져온다.
=> load and store 연산이 필요하다 -> 많은 레지스터값필요 -> 빅오버헤드..

다른 태스크로 전환하기 위한 일이긴하지만 useful한 일은 아니다.. 오버헤드.. 
=> 줄이는게 중요하다.
어케줄이냐, 아키텍쳐 레벨에서,
1. 멀티플 셋 레지스터(sun ultraSPARC)
2. 멀티플 스토어 앤 로드 인스럭쳐 제공 

26)
arm 아키텍쳐 예시(multiple load & store)
레지스터 한꺼번에 메모리에 로딩. -> new 프로세스를 위해.
old 프로세스는 store 해야함.

multiple load & store 가 제공이 안되면, 그림에서 로드를 4번해야함.. LDR 인스트럭쳐를..
=> 당연히 1번 인스럭쳐를 쓰는게 빠르게 때문에 multiple load & store 사용

이것은 아키텍쳐 레벨에서 지원해야함

그렇다면 소프트웨어인 os에서 지원해줘야할것은?
-> 학교수업으로 따지만 3연강, 4연강 하는것..
-> 컨택스트 스위치 횟수를 줄이려는 노력은 할 수 있지만, trade-off를 잘 살펴야한다..

27)
프로세스에 행해지는 오퍼레이션

뭐가 있느냐.
fork, exec, wait, exit -> 시스템콜이 어떻게 수행하는지 이해하는게 핵심!

28)
전형적으로 Unix 계열의 os는 프로세스를 트리형태로 관리한다.
-> fork를 호출한 프로세스가 parent 프로세스이다.
parent 프로세스가 child프로세스를 생성하는 구조.

각각의 프로세스는 PID(프로세스)를 가지고있다

29)
부모가 자식을 생성하는 구조.
그 때 생기는 이슈
- 리소스 sharing 부모가 가지고 있던 리소스가 있을텐데, 자식을 생성할때 그것을 다 공유할것이냐, 일부만 공유할것이냐, 아예 안할것이냐 => 정답은 일부만 공유. 부모에 의해 오픈된 파일만 자식에게 공유
- 부모와 자식의 수행 옵션 부모와 자식은 concurrnetly하게 수행이 가능하다. 자식프로세스를 사용하기위해선 쉐어하기 위해서. 많은경우 부모는 자식프로세스가 종료되기를 기다린다. 기다릴때까지 wait함수호출.
- 주소공간측면 prgram address space을 구성하는 4가지 요소 : 스택,힙,데이터,코드 -> 이 공간도 어떻게 할거냐~~ 처음에 자식은 부모의 어드레스 스페이스를 duplication한다. -> 자식과 부모는 처음에 동일안 어드레스 스페이스를 별도로 갖는다. -> 후에 exec 함수로 자식에게 새로운 프로그램 로딩.

