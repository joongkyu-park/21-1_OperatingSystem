# OS 11주차-2

42)
os는 비어있는 프레임을 관리하기 위해 frame table이라는 data structure을 둔다.

예.
4개의 페이지를 요청하는 프로세스 등장

os가 하는일
-> 비어있는 프레임의 테이블을 찾아서 할당시켜준다.

43)
어떤 프레임이 되어있나, 할당되지 않았나를 가지고 있는 테이블
-> 시스템에 1개있음. (프로세스마다 있는게 아니라)

페이지 테이블은 프로세스마다 있으므로 PCB 밑에서 관리

각각의 프로세스는 최대 몇 로지컬메모리를 가질 수 있을까
32bit 아키텍처 -> 이론상 000…000 ~ 111…111  -> 최대 4GB
![OS 11주차-2](images/OS%2011주차-2.png)

44)
페이징 기법의 MMU

페이징기법도 address translation이기 때문에 하드웨어의 지원(MMU)가 필요

-TLB(Translation look-aside buffer)
빠른 메모리. 특별히 look-up에 특성화된 메모리.
페이지 테이블을 룩업. -> 프레임넘버를 찾는다.
룩업하는 시간을 쭐이는게 중요하고, 그걸 빠르게 해주는게 TLB

원래는 PCB가 메모리에 있으므로 페이징테이블(p->f)을 보려면 메모리에 들어가야한다.
-> 빠른 접근을 위해 TLB에 테이블의 일부를 저장한다(빠르게 룩업가능해서)
그러나 TLB의 공간은 한정되어있으므로 일부만 저장되어있다

TLB먼저 찾고, 없으면 페이지테이블가서 찾는다.
(TLB에 있으면 베스트. 매우 빠름, 없으면 어쩔수 없이 메모리에 가서 페이징테이블)
![OS 11주차-2-1](images/OS%2011주차-2-1.png)

*address-space identifiers
TLB안에서 프로세스를 구분할 수 있는 identifiers
여러 프로세스를 TLB에 내포하기 위해서 address-space identifiers 필요하다

-Use of registers.

페이지테이블의 주소가 저장 되어있는 곳 : Page-table bae register(PTBR)

PRLR
페이지 테이블의 사이즈를 담고 있다.

45)
룩업이 빠른 이유는 parallel search가 가능하게 설계되어있어서.

46)
우리가 찾고자하는 page to frame 정보가 TLB에 있을 비율 높이자.
-> hit rate을 최대화 하자

47)
따라서 TLB이 반영된 address translation 모델로 다음과 같이 바뀐다.
![OS 11주차-2-2](images/OS%2011주차-2-2.png)

48)
얼마만큼 시간이 더 걸리는지 분석

입실론 : TLB를 찾는 시간
알파 : 우리가 찾고자하는 page to frame 정보가 TLB에 있을 확률

EAT 계산
![OS 11주차-2-3](images/OS%2011주차-2-3.png)

hit, miss 둘다 1이 필요한 이유
주소를 찾는 이유가 뭐야. 결국 해당 내용이 있는 메모리에 접근하기 떄문에 1은 기본적으로 필요함.

예) 입실론이 0.2 다 -> 메모리 접근 하는거보다 5배 빠르다.

질문)
알파가 1이라면?
1.2 (best)

알파가 0이라면?
2.2 (worst)

=> hit ratio를 늘리는게 매우 중요하다.

49)
memory protection

valid-invalid 비트를 확인하라.
valid-invalid 비트? -> 페이지 테이블에 추가된 비트

50)
(?)
여기 다시 확인

51)
여러 이슈

-Shared code 프로세스마다 페이징 테이블이 있는데, 두 프로세스의 페이징테이블이 shared code 영역을 가르킨다면?..
질문) 쉐어드 코드 영역(동일판 프레임넘버)을 가리키려면 버츄얼 어드레스 상에서 페이지넘버가 같아야한다? 아니면 다를 수도 있다?
-> 다를 수도 있다. 버츄얼 어드레스는 서로 다른 프로세스 간에는 전혀 상관없음
![OS 11주차-2-4](images/OS%2011주차-2-4.png)

-private code and data
각자 가지고 있는 코드

52)
페이지 테이블의 구조

![OS 11주차-2-5](images/OS%2011주차-2-5.png)

세가지 기법의 공통의 목표
-> 페이지 테이블의 크기를 줄이는 것

왜 페이지테이블 사이즈를 줄이는게 중요하냐
페이지테이블은 프로세스마다 있으므로, 그 공간을 많이 차지하게 되면 메모리 낭비가 심해진다

53)
32비트 주소체계로 최대 4GB의 로지컬어드레스를 나타낼 수 있다.

![OS 11주차-2-6](images/OS%2011주차-2-6.png)

프로세스 마다 4MB가 필요..

(?)
여기 다시

목표는 하나.
테이블 크기를 줄여보다

54)
하이라키컬 페이징
-> 프레임넘버를 찾으려면 2번 lookup을 하게 된다.

뭐야.. 페이지가 오히려 늘은거아닌가?

어떻게 줄인거냐.
2level 테이블에서 필요한 메모리 테이블만 남기고 다 지우기 때문.
![OS 11주차-2-7](images/OS%2011주차-2-7.png)

그러나 메모리 엑세스타임은 증가한다. 2번 룩업해야하기 때문

55)
따라서 어드레스를 2개가아니라 3개로 분할하여 나타낸다

56)
64비트 아키텍쳐같은 경우는
1level에 일단 모든 엔트리를 담고 있어야 하므로.. 2^42개
그럼 어떻게 해야하지?

57)
그럼 3레벨로 하자.

4레벨 5레벨도 되겠지만, 그럴 수록 메모리 엑세스타임이 늘어나게 된다.

58)
2번째. based page table
이거 역시 목표는 페이지테이블을 줄이기위함
-> 해싱기법사용

59)
페이지 넘버를 넣는 곳에 인자를 담고, 그거를 해시함수를 돌려서 해시테이블에서 찾는다. -> 사이즈를 줄일 수 있다.

해시가봅 특성상 collision은 어떻게 해결..? -> chain 형태로 관리

60)
마지막
inverted page table
테이블 크기를 줄이는 것이 목표
기본 아이디어 : 바뀌었음. 기존의 방식을 invert
![OS 11주차-2-8](images/OS%2011주차-2-8.png)

이게 왜 페이지테이블을 줄인거냐
![OS 11주차-2-9](images/OS%2011주차-2-9.png)

프로세스마다 있는게 아니라 OS에 1개 갖고있기때문..!

문제점.
예) A라는 프로세스의 7번 페이지의 5번 프레임이다
B라는 프로세스의 7번 페이지의 100번 프레임이다

이럴경우 어떻게 구분해?
=> process id가 더 추가되야한다. 동일한 페이지를 구별하기 위한.
![OS 11주차-2-10](images/OS%2011주차-2-10.png)

또.
이전에는 페이지넘버로 바로 찾을 수 있었는데, 
여기서는 바로 찾을 수 없기때문에 처음부터 쭉 다 서치해야함.
-> 서치타임증가

정리.
페이지 테이블이 하나 밖에 없기 때문에 메모리 크기를 많이 줄임
그러나 PID를 추가해야하고, 서치타임이 늘어난다.

61)
예

62)? 64)?
![OS 11주차-2-11](images/OS%2011주차-2-11.png)

Segmentation

segment란 logical unit이다. 정하기 나름.
보통 코드 세그먼트, 스택 세그먼트, 데이터 세그먼트 , , ,

핵심) 각각의 segment는 contiguous하게 저장.
그러나 프로세스 자체는 contiguous한게 아님

65)
논리적인 단위는 분할하기 나름

66)
이게 다음과같은 그림으로 저장
각각의 segment는 연속적이나, 전체적으로 보면 연속적이지 않음

그럼 결국 AT, MP가 핵심인데, 그거 어떻게하지?
(address translation, memory protection)

우선 세그먼트 테이블을 활용한다.
세그먼트 테이블에는 세그먼트 넘버가 있다.
AT를 하려면 -> 각각 세그먼트마다의 base address만 알면된다.
MP를 하려면 -> 세그먼트 각각이 contiguous하기 때문에, 세그먼트의 사이즈(limit)만 알면된다.
![OS 11주차-2-12](images/OS%2011주차-2-12.png)

따라서 세그먼트에서는 세그먼트 테이블만 있으면ㅁ된다

67)
세그먼트 테이블이 핵심

그렇다면 로지컬 어드레스는 어떻게 분할될까
=> 세그먼트 넘버와 offset로 분할된다.

69)
이 플로우 잘 확인.
![OS 11주차-2-13](images/OS%2011주차-2-13.png)

68)
로지컬유닛인 세그먼트로 나눔으로써 protection 도 할 수 있다.
ex) 코드 세그먼트는 read, write.. 중에 read만 가능한데 ,, , , ,

9장 정리.
![OS 11주차-2-14](images/OS%2011주차-2-14.png)

