# OS 13주차-2

25)
Allocation methods 

일반적으로 블락사이즈가 4KB
->4MB파일은 1024개의 블락으로 구성

이슈.
해당파일을 구성하는 1024개의 블락을 어떻게 스토리지에 저장하느냐
- Contiguous allocation 연속적으로 저장
- Linked allocation 연속적으로 저장하지는 않지만, 각 블락의 끝에 다음 블락의 주소를 적어놓는다

![OS 13주차-2](images/OS%2013주차-2.png)

- Indexed allocation 인덱스 블락이라는 곳에 블락넘버를 적어놓는다

![OS 13주차-2-1](images/OS%2013주차-2-1.png)

26)
Contiguous allocation

각 파일은 디스크에 연속적인 블락으로 저장되어있다.

read는 현재 file position pointer 부터 읽는다.
현재 위치가 21K이라고 해보자.
파일이 있을때 21KB서부터 떨어진 곳부터 읽는다. offset이 21KB라는 뜻
그럼 21KB만큼 떨어진 위치는 몇번째 블락일까.
하나의 블락이 4KB이니까 6번째 블락 이겠다.
-> direct access이다. 시작위치만 알면 원하는 블락에 직접적으로 접근가능하다.
따라서 예를 들어 starting location, 즉 시작위치 블락넘버가 5번이다.
그러면 -> 10번 블락부터 읽으면된다.(5번부터 시작해서 6번째)
따라서 시작블록의 위치치와 블락의 수만 알면된다.

디스크 내에 연속적으로 저장되어있기때문에 head movement가 없다. 그냥 쭉 읽어들이면된다.

구현도 간단하다.
예를 들어 sequential access(영화같은 비디오를 본다고하자)같은경우 쉽다. -> 그냥 연속적으로 읽으면 되니까.
-> 비디오를 멈추면 그냥 최종 블락넘버를 기록만 해주면 된다.
연속적으로 저장되었기때문에 간단하게 구현히 가능하다.

27)
문제점
- Contiguous하기 때문에  -> external fragmentation, 즉 외부단편화 문제 발생.
- file을 write연산을 통해 확장하는게 힘들다

28)
- 이와 같은 상황에서, 예를들어 8개의 블락을 연속적으로 저장하고싶다.

	-> 불가능하다.. 남아있는 블락의 총합은 15개인데..

- 파일을 확장시키는 것이 어렵다. tr이라는 파일을 editing한다. 18번째블락을 넘어버리면, contiguous하게 저장하려다가 저장을 못하게된다..

이런 문제점이 있다

29)
해결법

Extent-based allocation
디스크의 연속적인 블락을 의미. 가능한 연속적오르로.
하나의 extent의 끝에 다음 extent의 주소를 적어놓은것.
noncontiguous해 진것.
파일은 1개 또는 그이상의 extent로 이루어진다.

28)의 tr같은경우 18번째까지 블락을 쓰고, 넘어버리면 다른 연속적인 extent를 쓰면 되겠다.

30)
Linked allocation
이전블락의 다음블락주소를 기록

외부단편화 문제, 파일확장문제 해결

문제점
direct access의 문제.
파일의 특정위치를 직접적으로 파일 연산하는것.
예) 이 파일을 구성하는 3번째 블락을 읽어라.
이와같은경우는 1번째블락부터 시작해서 다 뒤져봐야함. 그이전의 블락들을 모두 한번 읽어봐야 해당 블락의 위치를 찾을 수 있음.

31)
또다른 문제.
다음 블락넘버를 이전블락에 기록해줘야하는데,
만약 블락사이즈가 512라고하면 4Byte가 블락마다 필요 -> 0.78%의 스토리지를 낭비하게됨. 
뭐 이건 그럴 수 있어.

가장 큰 문제는
포인터가 손상되어버리면, 그 이후에 대한 정보를 찾을 수 가 없다.
예를들어 30)에서 16번째 블락이 dead 블락이 되어버리면, 그이후의 블락들을 찾을 수 없다
-> 신뢰성의 문제가 크다.

32)
가장 유명한 파일시스템 중 하나.
FAT(File Allocation Table) 파일시스템. 마이크로소프트에서 쓰이는 파일 기법.
이 FAT 파일시스템이 Linked allocation을 변형해서쓴다.

다음 블락넘버를 블락내에 기록하는것이 아니라,
FAT은 다음 블락 위치를 기록한 테이블로 관리한다.

테이블의 엔트리중에 아무것도 할당되지 않은 것은 0으로 기록.

파일의 마지막 블락넘버의 다음을 적어야하는 엔트리에는 EOF가 들어가겠다.

테이블의 엔트리의 개수 = 디스크안의 블락의 총개 수.
모든 블락을 표현해야하기 떄문

33)
Indexed allocation

각 파일마다 인덱스블락이 있다.
해당 인덱스블락에 파일을 구성하는 블락넘버들이 적혀있다.

리눅스 유닉스계열에서 보편적으로 사용

질문.
하나의 블락이 4KB인데, 인덱스블락안에 블락넘버를 하나 적는게 4B라고하자.
인덱스 블락이 1개라면 파일의 최대크기는?
-> 총 1024개의 블락이 들어갈 수 있으므로, 4MB이다.
즉 인덱스블락 1개로 표현할 수 있는 파일의 최대 크기가 4MB
-> 문제가 되겠다.. 너무 작잖아

이 파일크기제한 문제를 어떻게 해결했나

34)
인덱스블락의 사이즈 문제

- Linked scheme 인덱스 블락 1개
- Multilevel index 레벨로 구성
- Combined scheme 인덱스 블락 개수를 여러개. 인덱스 블락을 안두는 경우도 있고(=Direct block) -> 인덱스 블락을 이용하지않고 해당 파일을 구성하는 블락넘버를 FCB에 기록함. 1개두는 경우도 있고(=Single indeirect) -> 4MB 2레벨 -> 4GB 3레벨 -> 4TB 이런것들을 혼합해서 사용한다.

![OS 13주차-2-2](images/OS%2013주차-2-2.png)

35)
Linked scheme
인덱스 블락 1개
1024개의 블락 표현가능 -> 파일사이즈의 최대크기 4MB

36)
Multilevel index

outer-index : 실제 파일을 구성하는 데이터 블락넘버가 아니라, 인덱스 블락의 넘버
outer-index에서의 1개의 인덱스블락넘버는, index table에서 1024개의 데이터블락넘버를 가지고 있을 수 있겠다.

질문.
이 파일을 구성하는 1024번째의 블락넘버는?
500.
그럼 파일을 구성하는 1번째 블락넘버?
7.
그럼 1025번째 블락넘버?
1000.

질문.
총 몇개의 엔트리가 index table에 있을 수 있나.
1024 * 1024개 블락 -> 4GB
![OS 13주차-2-3](images/OS%2013주차-2-3.png)

최근의 고화질의 영상,, 이런 것은 4GB로 안된다 -> 3 level로 둔다.
-> 1024 * 1024 * 1024 = 4TB. 파일 하나가 최대 4TB를 가질 수 있다.

37)
이것의 문제
파일의 위치를 찾기 위해 2번의 index block의 read가 필요하다.
물론 자주 방문하는건 메모리에 기록해두겠지만
가능한한 read를 줄이자

38)
그래서 도입된것이 Combined scheme
리눅스, 유닉스에서 사용

해당 그림은 FCB(=inode)
direct blocks에는 index block이 아니라 실제 data block의 넘버가 들어간다.
총 12개의 엔트리가 들어갈 수 있기 때문에, 총 48KB이하의 파일들은 index 블락을 읽을 필요가 없다.
single indirect-> linked scheme
double indirect -> 멀티레벨중 2 level
triple indirect -> 멀티레벨 중 3  level

질문.
리눅스에서의 1개파일의 크기?
4TB + 4GB + 4MB + 48KB

![OS 13주차-2-4](images/OS%2013주차-2-4.png)

39)
지금까진 정통적인 파일시스템에 대해 배웠다.
이번엔 약간 좀 다른 방법의 파일시스템인 log-structured file system.

파일시스템을 구성하는데에 있어서 가장 중요한 것은 consistency.
consistency : meta-data와 data의 일치하는 정도. 일관적이어야함.
이게 제일 중요한 요소중 하나이다.

파일시스템을 적용하다보면 consistency가 위배되는 경우가 많이 있을 수 있다.

파일생성 시
1. 파일생성 -> FCB(inode)가 할당되어야하고
2. 데이터 블락이 할당되어야하고
3. free count가 감소되어야하고(메타데이터)
4. 디렉토리 스트럭쳐가 그 파일을 가리키도록 수정이되어야한다

만약 3번과 4번 사이에서 전원이 나갔다. -> 4번은 수행못함
FCB는 생성되었지만, 파일에 대한 디렉토리 스트럭쳐는 반영이 안된다.
파일을 읽고 쓸 때 디렉토리 스트럭쳐 읽어야하는데..?
-> inconsistency 발생

이런 현상이 비일비재하게 발생할 수 있다.

어떻게 해결?
40)
기록을 남기는게 핵심. log에 다가.
크래쉬 나는건 어쩔 수없는 상황
log에다가 transaction들을 남겨둔다. 파일시스템에 대한 업데이트들을 transaction이라고 부른다.
일련의 transaction들이 기록될텐데(위에서의 4개 스텝들)
이게 4번까지 완벽히 수행되어야 파일시스템에 반영한다.
파일시스템에 반영하면 그제서야 log에서 기록을 지운다.
all or nothing 이다. 비동기적으로 이루어진다.

![OS 13주차-2-5](images/OS%2013주차-2-5.png)

만약 log에 1~4번까지 다 기록했고.
파일시스템에 업데이트하는 와중에 crash가 났다.
-> 기록이 되었기때문에 기록을 보고 업데이트하면된다.

이러한 것들 덕분에 파일시스템 자체는 consistent하게 유지된다.

41)
두번 째.
NFS(네트워크 파일 시스템)
A사용자가 B기기의 스토리지에 직접 접근하여 read, write, excute을 할 수 있는것

42)
NFS서버, NFS클라이언트가 있다.

1. 서버는 특정 디렉토리만(공유하고싶은) NFS 서버에 export한다.
2. 클라이언트는 그 export한 디렉토리를 mount한다
3. 사용자는 그 이후로부터 자기 local 스토리지 인 냥 마음대로 read, write등 접근 할 수 있게 된다

43, 44)
실제예시

