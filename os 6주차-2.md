# os 6주차-2

38)
멀티레벨 큐

핵심
레디큐를 여러개 큐로 분할한다.
태스크마다 진입해야할 큐가 이미 정해져있다.
태스크안에 자기만의 스케줄링이 있고 -> round robin쓸수있고, fcfc 쓸수있고, …
큐 간의 스케줄링이 있다.

핵심
1. 태스크마다 진입해야할 큐가 ‘이미’ 정해져있다.
2. 태스크 안의 자기만의스케줄링이 있다
3. 큐간의 스케줄링이 있다. -> 큐에서 나온 대표 태스크들 중에 하나 고름 fixed priority 쓸수도있고, time slice 쓸수도있고.

39)
여기서는 fixed priority를 쓰지만 중요한게 아님
큐간의 스케줄링은 os의 정책에따라 달라질 수 있다.

40)
멀티레벨 피드백 큐.

멀티레벨 큐 -> 큐간의 태스크가 움직이는거 허용 x
멀티레벨 피드백 큐 -> ⭐️프로세스가 큐간에 움직일 수 있다.

어떤 추가조건이 더 있나
- 역시 큐의 개수를 먼저 정의해야함
- 역시 큐안의 스케줄링도 있어야함
- 그러나, 두가지조건이 더추가된다.
- 

- 태스크가 속한 큐가 정해져있다. 이건 똑같음.

![os 6주차-2](images/os%206주차-2.png)

초록색은 멀티레벨큐와 같은거고, ->
보라색은 멀티레벨피드백큐가 프로세스간 이동을 가능하게 하기 위해 추가한 조건

41)
단순한 예

이 스케줄링은 그냥 단순히 예든거.

큐간의 마이그레이션 정책이 추가적으로 들어가있다.

42)
앞의 예시를 그림으로.

하나의 예니까 크게 신경쓸 필요없다.

43)
단일프로세서환경에서 멀티프로세서 환경으로 전환해보자.

멀티프로세서 -> 코어가 여러개있는경우 또는 cpu가 여러개있는경우
	-> 어떤 cpu에게 태스크를 할당할지가 중요함 -> os가 하는일.

시메트릭 멀티프로세싱 ,어시메트릭 멀티프로세싱 차이?
	프로세스간에 master-slave관계가 있다.
	아키텍쳐 측면에서는(메모리관리측면에서) 쉐어드메모리와 프라이빗메모리의 여부에따라 차이있었다.

44)
중요하게 생각해야하는것.
- process affinity(친밀도) cpu와 태스크간의 친밀도가 있다고 포현. -> 너무 추상적인데??.. 다음 슬라이드에서 예시
- load balancing 태스크의 로드밸런싱을 고려해야한다. 한쪽 cpu에게 너무많이 주면..

45)
cpu1에서 태스크 수행.
-> cpu1의 프로세스1의 일부가 캐시로 올라간다.

=> 이 상황에서 재할당해야하는 상황이 왔는데, cpu2로 프로세스를 다시옮기는거보다 cpu1에서 그대로 수행하는게 효과적이므로
-> 이때 cpu1과 프로세스1이 affinity 관계가 있다고 표현.

46)
소프트 어피니티
: 관계가 소프트하다
os이 해당 어피니티를 고려해서 할당해줄려고 노력은하나, 보장은 못함

하드 어피니티
: 관계가 하드하다
항상 보장함. 언제 하드 어피니티가 보장될까?
a라는 프로세스가, 나 이 cpu에(또는 이 코어에)할당해줘, 라고 요청했을때 os는 따를수밖에없음.
![os 6주차-2-1](images/os%206주차-2-1.png)

어떻게 요청할까? => 방법하나잖아. 시스템콜.

리눅스는 하드어피니티를 지원한다.
그 소리는 뭘까?
리눅스에 특정 cpu나 특정 코어를 할당할 수 있는 시스템 콜이 있다는 말.
(sched-setaffinity라는 시스템콜. 특정 cpu에 할당하지 말아달라,, 뭐 이런것도 옵션으로 설정가능)
응용프로그래머가 저 함수를 호출해서 직접 할당할 수 있다

47)
두번째 이슈, 로드밸런싱

두가지방법있음

1. push migration

전체 cpu의 워크로드를 모니터링하는 태스크가 있음. (빨간색 별)
-> 한쪽 cpu에 일이 많다하면 로드를 재분배까지 해줌. 태스크를 푸쉬해줌. 로드밸런싱을 위해

48)
2. pull migration

각각의 cpu가 자신의 워크로드를 모니터링함
워크로드가 낮을경우,  다른 태스크가 많은 유틸라이제이션이 높은(오버로드된) cpu로부터 태스크를 pull해온다.
=> 리눅스는 이 기법사용고 있다.

50)
스레드 스케줄링

오른쪽아래그림으로 시나리오 예시
![os 6주차-2-2](images/os%206주차-2-2.png)

os는 커널스레드를 스케줄링, 흔히 말하는 스케줄링 -> 글로벌 스케줄링

유저스레드 중 하나를 선택하는건 스레드 라이브러리.

51)
리눅스 스케줄링이 어떻게 이루어지는지에 대해 설명한다.

두 개의 클레스로 나누어진다

컨벤셔널 클래스
리얼타임 클래스
-> 클래스가 여러개네, 멀티레벨큐가 생각난다.

1번 이슈
특정태스크가 어떤 클래스인지 구분하지?
-> Priority로구분
0~99 가 리얼타임 클래스
100~139가 컨벤셔널 클래스

즉 어떤 큐에 들어갈지에 대해 결정된것

큐안의스케줄링, 큐간의 스케줄링은 어떻게?

2번이슈
큐안의 스케줄링
리얼타임클래스는 priority-based scheduling
컨벤셔널클래스는 CFS(completely fair scheduler(sharing))

3번 이슈
큐간의 스케줄링? -> priority scheduling
![os 6주차-2-3](images/os%206주차-2-3.png)

큐간의 스케줄링 어떻게할까.

만약 리얼타임클래스 태스크가 1개, 컨벤셔널클래스 태스크가 40개라면?

 priority scheduling 이므로,
리얼타임클래스에 태스크가 1개라도 있으면 컨벤셔널클래스에 있는 태스크 실행 x
리얼타임클래스 먼저 실행

fork랑 pthread_create함수 호출 -> 어느클래스에속할까? -> 디폴트로 컨벤셔널에 속함
리얼타임에 속하고싶으면? “pthread_attr_init”함수(api)를 잘이용하면 리얼타임클래스로 설정가능.

52)
여기선 왜 3개의 클래스라고 나오지?
기본적으로 리얼타임, 컨벤셔널인데

리얼타임이 2개로나 뉨
FIFO와 RR로.
이 두개 어떻게구별? 어떤 차이가 있나?

53)
리얼타임클래스는 큐안의 스케줄링이 priority기반 스케줄링을 쓴다.
근데
![os 6주차-2-4](images/os%206주차-2-4.png)

이렇게 나뉜다. 둘다 priority기반 인데 조금 다르다.

54)
해당 그림이 FIFO
우선순위가 가장높은 p1이나 p2중 수행하는데 -> 가장먼저 도착한 태스크, 즉 p1 먼저 수행
-> 우선순위가 높은 태스크가 완전히 끝날때까지(레디큐를빠져나갈때까지) 실행하고
빠져나가면 그다음 다음꺼 실행

55)
RR
여기서도 먼저 P1이 수행되는데, 끝까지 수행되는게 아니라 타임퀀텀까지만 수행
타임퀀텀이 완료되면 p2실행, p1이 뒤로 밀림.
-> 우선순위 기반이긴한데, 그 같은 우선순위 내에서 타임퀀텀을 두고 번갈아서 실행

56)
컨벤셔널 클래스는 어떻게 수행될까.

57)
cfs 스케줄러의 기본 아이디어

각 태스크별로(A,B,C) weight(비중)이 있다.
비중의 비율만큼 프로세스들을 실행.
가능한한 모든 시점에서 보장을 해줘야한다.
어느 시점에서 보더라도 다 만족시킬수 있다..? 아니다
->특정시점에 실행시킬 수 있는 태스크는 오직 1개이므로..

58)
예시
왼쪽과 오른쪽 모두다 결국 2:1 비율이 된다
그런데 어떤게 CFS 원칙에 더 적절한가? -> 1번.
가능한한 많은 시점에 2:!을 유지시키고있음. 조금더 fair 하다
![os 6주차-2-5](images/os%206주차-2-5.png)

59)
버츄얼 타임이라는 것을 도입.
64비트의 변수(vruntime)가 태스크마다 있음.

⭐️vruntime이 가장 작은 값을 스케줄러에서 선택.

vruntime이 어떻게 계산되냐?

60)
![os 6주차-2-6](images/os%206주차-2-6.png)

delta_exec : 방금전에 수행됐던 시간
![os 6주차-2-7](images/os%206주차-2-7.png)

여기선 10ms마다 체킹했다고 가정.

매 시점마다 vruntime을 계산하여 더 작은 값을 가지는걸 실행.
태스크의 weight와 이전까지 진행했던 시간을 고려하게 된다.

질문. weight 값은 어떻게 정해지나?
-> 컨벤셔널클래스는 100~139까지 할당되는데,
그 우선순위 값에 따라 Weight이 결정

